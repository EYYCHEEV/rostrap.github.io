{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RoStrap \u00b6 RoStrap is the name of a Roblox plugin and resource management system designed to expedite game development on Roblox. Its main goals are to increase code reusability and simplify the networking of resources without penalty for not using features . The plugin allows for easy access and installation of incredibly useful libraries. With the click of a button you can start using an optimized rewrite of the vanilla Lua os.date function: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Date = Resources : LoadLibrary ( \"Date\" ) print ( Date ( \"!%c\" , tick ())) -- Thu Jan 31 08:55:48 2020 Or use a beautiful Choice Dialog: -- If this is in a Script, it will Replicate this ChoiceDialog to every -- Player in the game and everyone who joins -- If this is in a LocalScript, it will generate it on the client only local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local PrimaryColor3 = Color . Teal [ 500 ] local Dialog = PseudoInstance . new ( \"ChoiceDialog\" ) Dialog . HeaderText = \"Repository Location\" Dialog . Options = { \"ServerStorage\" , \"ServerScriptService\" } Dialog . DismissText = \"CANCEL\" Dialog . ConfirmText = \"INSTALL\" Dialog . PrimaryColor3 = PrimaryColor3 Dialog . OnConfirmed : Connect ( function ( Player , Choice ) print ( Player , Choice ) if Choice then -- Choice is a string of the option they chose else -- They chose Dismiss, so Choice is false end end ) Dialog . Parent = ReplicatedStorage Or manage your RemoteEvents and RemoteFunctions! local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Chatted = Resources : GetRemoteEvent ( \"Chatted\" ) local ClientLoaded = Resources : GetRemoteFunction ( \"ClientLoaded\" )","title":"Introduction"},{"location":"#rostrap","text":"RoStrap is the name of a Roblox plugin and resource management system designed to expedite game development on Roblox. Its main goals are to increase code reusability and simplify the networking of resources without penalty for not using features . The plugin allows for easy access and installation of incredibly useful libraries. With the click of a button you can start using an optimized rewrite of the vanilla Lua os.date function: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Date = Resources : LoadLibrary ( \"Date\" ) print ( Date ( \"!%c\" , tick ())) -- Thu Jan 31 08:55:48 2020 Or use a beautiful Choice Dialog: -- If this is in a Script, it will Replicate this ChoiceDialog to every -- Player in the game and everyone who joins -- If this is in a LocalScript, it will generate it on the client only local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local PrimaryColor3 = Color . Teal [ 500 ] local Dialog = PseudoInstance . new ( \"ChoiceDialog\" ) Dialog . HeaderText = \"Repository Location\" Dialog . Options = { \"ServerStorage\" , \"ServerScriptService\" } Dialog . DismissText = \"CANCEL\" Dialog . ConfirmText = \"INSTALL\" Dialog . PrimaryColor3 = PrimaryColor3 Dialog . OnConfirmed : Connect ( function ( Player , Choice ) print ( Player , Choice ) if Choice then -- Choice is a string of the option they chose else -- They chose Dismiss, so Choice is false end end ) Dialog . Parent = ReplicatedStorage Or manage your RemoteEvents and RemoteFunctions! local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Chatted = Resources : GetRemoteEvent ( \"Chatted\" ) local ClientLoaded = Resources : GetRemoteFunction ( \"ClientLoaded\" )","title":"RoStrap"},{"location":"Contributing/","text":"Contributing \u00b6 If you wish to contribute a Library, simply submit a pull request to Libraries.lua . Simply insert a new table with fields URL (you can leave off https://github.com ) and an optional Description and you are good to go! Library Standards \u00b6 Libraries contributed to RoStrap must be useful, reusable, and reasonably universal. The code must be stable, maintained, readable, and speedy. It must have a readme or documentation website that clearly outlines its use and includes functioning demo code. Images help. Submitted Libraries may be subject to code review. All images must meet the image standards Plugin \u00b6 The following documentation outlines how the plugin works its magic. Library Discrimination \u00b6 When the RoStrap plugin sees your URL within Libraries.lua , it will figure out how many Libraries exist within the directory located at the URL (which can be a link to a single file). If Lua files are descendants of another Lua file, they will be considered a single Library. Find the definition of a Library here . To indicate to the plugin's installer that a Lua file is a descendant of another, simply make a folder with the name of the parent Lua file, and place the parent Lua file inside with the name \"init\" (or \"main\" or \"_\"). Here is an example of a single Library that has ModuleScripts within it. Folders containing multiple Lua files with names containing the name of a ancestor folder will also be considered a single installable-package by the plugin. Examples of this to come. Libraries that should be installed and packaged differently from all of the already-integrated Libraries may require adjustment on the Plugin's part. In this case, do what makes the most sense for your GitHub repository or consider adding fields to the Libraries table and the installer will be adjusted. Dependencies \u00b6 Dependencies are detected by the plugin using this handy script . It can detect from the following source code that Tween and Maid are the names a Library will need to have installed in order to work. If your source code intends to rely on dependencies from the RoStrap system, the detection script must be able to successfully determine the dependencies of your Libraries. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- You have to use game:GetService local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) -- You have to use WaitForChild local require = Resources . LoadLibrary -- You can localize LoadLibrary local Tween = require ( \"Tween\" ) -- Either of these work local Maid = Resources : LoadLibrary ( 'Maid' )","title":"Information"},{"location":"Contributing/#contributing","text":"If you wish to contribute a Library, simply submit a pull request to Libraries.lua . Simply insert a new table with fields URL (you can leave off https://github.com ) and an optional Description and you are good to go!","title":"Contributing"},{"location":"Contributing/#library-standards","text":"Libraries contributed to RoStrap must be useful, reusable, and reasonably universal. The code must be stable, maintained, readable, and speedy. It must have a readme or documentation website that clearly outlines its use and includes functioning demo code. Images help. Submitted Libraries may be subject to code review. All images must meet the image standards","title":"Library Standards"},{"location":"Contributing/#plugin","text":"The following documentation outlines how the plugin works its magic.","title":"Plugin"},{"location":"Contributing/#library-discrimination","text":"When the RoStrap plugin sees your URL within Libraries.lua , it will figure out how many Libraries exist within the directory located at the URL (which can be a link to a single file). If Lua files are descendants of another Lua file, they will be considered a single Library. Find the definition of a Library here . To indicate to the plugin's installer that a Lua file is a descendant of another, simply make a folder with the name of the parent Lua file, and place the parent Lua file inside with the name \"init\" (or \"main\" or \"_\"). Here is an example of a single Library that has ModuleScripts within it. Folders containing multiple Lua files with names containing the name of a ancestor folder will also be considered a single installable-package by the plugin. Examples of this to come. Libraries that should be installed and packaged differently from all of the already-integrated Libraries may require adjustment on the Plugin's part. In this case, do what makes the most sense for your GitHub repository or consider adding fields to the Libraries table and the installer will be adjusted.","title":"Library Discrimination"},{"location":"Contributing/#dependencies","text":"Dependencies are detected by the plugin using this handy script . It can detect from the following source code that Tween and Maid are the names a Library will need to have installed in order to work. If your source code intends to rely on dependencies from the RoStrap system, the detection script must be able to successfully determine the dependencies of your Libraries. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- You have to use game:GetService local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) -- You have to use WaitForChild local require = Resources . LoadLibrary -- You can localize LoadLibrary local Tween = require ( \"Tween\" ) -- Either of these work local Maid = Resources : LoadLibrary ( 'Maid' )","title":"Dependencies"},{"location":"Getting-Started/","text":"Getting Started \u00b6 To begin using RoStrap, simply install it: After installing, open a place and enable Http requests from Home \u2192 Game Settings \u2192 Security. Next, navigate to the PLUGINS tab. Click the RoStrap logo. The plugin will install the Resources library and create an example \"Repository\" folder in ServerStorage from which libraries may be loaded using LoadLibrary Only Folders and libraries should go in this repository. Folder heiarchy of libraries is ignored. A ModuleScript and its descendants are considered a single library. Thus, only parent ModuleScripts will be accessible via LoadLibrary Example local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Keys = Resources : LoadLibrary ( \"Keys\" ) -- Keys local Thin = Resources : LoadLibrary ( \"Thin\" ) -- Error! Not a valid library","title":"Getting Started"},{"location":"Getting-Started/#getting-started","text":"To begin using RoStrap, simply install it: After installing, open a place and enable Http requests from Home \u2192 Game Settings \u2192 Security. Next, navigate to the PLUGINS tab. Click the RoStrap logo. The plugin will install the Resources library and create an example \"Repository\" folder in ServerStorage from which libraries may be loaded using LoadLibrary Only Folders and libraries should go in this repository. Folder heiarchy of libraries is ignored. A ModuleScript and its descendants are considered a single library. Thus, only parent ModuleScripts will be accessible via LoadLibrary Example local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Keys = Resources : LoadLibrary ( \"Keys\" ) -- Keys local Thin = Resources : LoadLibrary ( \"Thin\" ) -- Error! Not a valid library","title":"Getting Started"},{"location":"Libraries/","text":"Libraries \u00b6 When you use RoStrap, you are using tested and tried Libraries which are continually maintained by the best developers in town! Whenever a developer updates their Library on GitHub, you will see an update button appear (under the INSTALLED tab). Installing or updating a library automatically installs its dependencies. Updates are detected when your source code doesn't match the source code of the latest version of GitHub, excluding whitespace, comments, and configurable variables . Configurable variables have to look like this: local ALL_CAMEL_CASE = \"SINGLE-LINE-VALUE\"","title":"Introduction"},{"location":"Libraries/#libraries","text":"When you use RoStrap, you are using tested and tried Libraries which are continually maintained by the best developers in town! Whenever a developer updates their Library on GitHub, you will see an update button appear (under the INSTALLED tab). Installing or updating a library automatically installs its dependencies. Updates are detected when your source code doesn't match the source code of the latest version of GitHub, excluding whitespace, comments, and configurable variables . Configurable variables have to look like this: local ALL_CAMEL_CASE = \"SINGLE-LINE-VALUE\"","title":"Libraries"},{"location":"Resources/","text":"Resources \u00b6 Resources is the core resource manager and library loader for RoStrap. It is designed to streamline the retrieval and networking of resources and centralize the loading of libraries. Functionality \u00b6 Upon being required on the server for the first time, Resources moves libraries within ServerStorage.Repository to folder ReplicatedStorage.Resources.Libraries , where both the client and server can require them via the function LoadLibrary . Only Folders and libraries should go in this repository. Folder heiarchy of libraries is ignored. A ModuleScript and its descendants are considered a single library. Thus, only parent ModuleScripts will be accessible via LoadLibrary Anything within the Repository with \"Server\" (case-sensitive) in its name as well as its children will not be accessible to clients This includes Folders , libraries, and descendants of libraries. Server-only objects will be located within folder ServerStorage.Resources Info Internally, LoadLibrary caches and returns require(Resources:GetLibrary(LibraryName)) . GetLibrary is the only function that can \"retrieve\" objects from both ServerStorage and ReplicatedStorage . This is because server libraries are added directly to its cache. Note Libraries will not be moved into ReplicatedStorage in Play-Solo (to allow for editing libraries during Play-Solo). API \u00b6 All methods of Resources have hybrid syntax, meaning they can be called using either a : or . LoadLibrary \u00b6 Variant Resources: LoadLibrary ( string LibraryName) A require-by-string function which internally calls require(Resources:GetLibrary(string LibraryName)) and caches the results. Example local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) -- Some people like to overwrite the default require function local require = Resources . LoadLibrary local Signal = require ( \"Signal\" ) Info This is the only function with a hard-coded name for its cache, so you may access cached require results using the following: -- Resources uses this table to cache LoadLibrary results local LoadedLibraries = Resources : GetLocalTable ( \"LoadedLibraries\" ) Get functions \u00b6 Ref<Instance> Resources: GetCLASSNAME ( string InstanceName) Get functions can be procedurally generated by Resources at run-time in the form of Resources:GetCLASSNAME(string InstanceName) . These functions return an Instance named InstanceName under Resources:GetFolder(CLASSNAME:gsub(\"y$\", \"ie\") .. \"s\") . On the server, missing instances will be instantiated via Instance.new . On the client, the function will yield for the missing instances via WaitForChild . The following is the internal call tree. Keep in mind that these functions cache so the 3 rd function will only run once per machine and GetFolder will only run once per function generation (e.g. the first time GetRemoteEvent is called). Step Object to search for Function call 1 RemoteEvent Chatted inside GetRemoteEvent(\"Chatted\") 2 Folder RemoteEvents in GetFolder(\"RemoteEvents\") 3 Resources ROOT Info Caches results in Resources:GetLocalTable(CLASSNAME:gsub(\"y$\", \"ie\") .. \"s\") Example Get functions can also manage instance types that aren't instantiable by Instance.new . However, these instances must be preinstalled in the locations in which they would otherwise be instantiated because they cannot be generated at run-time. This allows you to do things like the following: local Falchion = Resources : GetSword ( \"Falchion\" ) GetLocal functions \u00b6 Ref<Instance> Resources: GetLocalCLASSNAME ( string InstanceName) Get functions in the form of GetLocalCLASSNAME work in the same way as regular Get functions, except clients may also instantiate missing instances and GetLocalFolder searches in different locations. Not meant to be used very much. Machine LOCALSTORAGE LOCALRESOURCES Server ServerStorage ServerStorage.Resources Client Players.LocalPlayer.PlayerScripts Players.LocalPlayer.PlayerScripts.Resources Step Object to search for Function call 1 BindableEvent Attacking inside GetLocalBindableEvent(\"Attacking\") 2 Folder BindableEvents in GetLocalFolder(\"BindableEvents\") 3 Folder LOCALSTORAGE.Resources LOCALRESOURCES Example local Attacking = Resources : GetLocalBindableEvent ( \"Attacking\" ) Here is what the above code would do if ran by the server versus what it would do if ran by a client: Server Client Warning In Play-Solo Mode, all local objects will go under ServerStorage , as there is no difference between the client and server. If you use identical Local-function calls on the client and server, this could cause conflicts in Play-Solo. The same problem applies to caches, which have \"Local\" appended to the front of the string to differentiate from regular caches. LOCALSTORAGE is typically just for GetLocalBindableEvent calls and having a place to store server-only Libraries, which are under GetLocalFolder(\"Resources\") . GetLocalTable \u00b6 table Resources: GetLocalTable ( string TableName) A function which caches a local table by string, and returns said table. Does not replicate. Useful for eliminating the need for _G or ModuleScripts which return an empty table. Note Because this is hard-coded and not procedurally generated, it doesn't obey the rules of other GetLocal functions. Example -- Can be used in any script on the same machine to get this table local MyItems = Resources : GetLocalTable ( \"MyItems\" ) -- {} Info Resources uses GetLocalTable internally, so you can access its internals using this function: -- Resources uses this table to cache LoadLibrary results local LoadedLibraries = Resources : GetLocalTable ( \"LoadedLibraries\" )","title":"Resources"},{"location":"Resources/#resources","text":"Resources is the core resource manager and library loader for RoStrap. It is designed to streamline the retrieval and networking of resources and centralize the loading of libraries.","title":"Resources"},{"location":"Resources/#functionality","text":"Upon being required on the server for the first time, Resources moves libraries within ServerStorage.Repository to folder ReplicatedStorage.Resources.Libraries , where both the client and server can require them via the function LoadLibrary . Only Folders and libraries should go in this repository. Folder heiarchy of libraries is ignored. A ModuleScript and its descendants are considered a single library. Thus, only parent ModuleScripts will be accessible via LoadLibrary Anything within the Repository with \"Server\" (case-sensitive) in its name as well as its children will not be accessible to clients This includes Folders , libraries, and descendants of libraries. Server-only objects will be located within folder ServerStorage.Resources Info Internally, LoadLibrary caches and returns require(Resources:GetLibrary(LibraryName)) . GetLibrary is the only function that can \"retrieve\" objects from both ServerStorage and ReplicatedStorage . This is because server libraries are added directly to its cache. Note Libraries will not be moved into ReplicatedStorage in Play-Solo (to allow for editing libraries during Play-Solo).","title":"Functionality"},{"location":"Resources/#api","text":"All methods of Resources have hybrid syntax, meaning they can be called using either a : or .","title":"API"},{"location":"Resources/#loadlibrary","text":"Variant Resources: LoadLibrary ( string LibraryName) A require-by-string function which internally calls require(Resources:GetLibrary(string LibraryName)) and caches the results. Example local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) -- Some people like to overwrite the default require function local require = Resources . LoadLibrary local Signal = require ( \"Signal\" ) Info This is the only function with a hard-coded name for its cache, so you may access cached require results using the following: -- Resources uses this table to cache LoadLibrary results local LoadedLibraries = Resources : GetLocalTable ( \"LoadedLibraries\" )","title":"LoadLibrary"},{"location":"Resources/#get-functions","text":"Ref<Instance> Resources: GetCLASSNAME ( string InstanceName) Get functions can be procedurally generated by Resources at run-time in the form of Resources:GetCLASSNAME(string InstanceName) . These functions return an Instance named InstanceName under Resources:GetFolder(CLASSNAME:gsub(\"y$\", \"ie\") .. \"s\") . On the server, missing instances will be instantiated via Instance.new . On the client, the function will yield for the missing instances via WaitForChild . The following is the internal call tree. Keep in mind that these functions cache so the 3 rd function will only run once per machine and GetFolder will only run once per function generation (e.g. the first time GetRemoteEvent is called). Step Object to search for Function call 1 RemoteEvent Chatted inside GetRemoteEvent(\"Chatted\") 2 Folder RemoteEvents in GetFolder(\"RemoteEvents\") 3 Resources ROOT Info Caches results in Resources:GetLocalTable(CLASSNAME:gsub(\"y$\", \"ie\") .. \"s\") Example Get functions can also manage instance types that aren't instantiable by Instance.new . However, these instances must be preinstalled in the locations in which they would otherwise be instantiated because they cannot be generated at run-time. This allows you to do things like the following: local Falchion = Resources : GetSword ( \"Falchion\" )","title":"Get functions"},{"location":"Resources/#getlocal-functions","text":"Ref<Instance> Resources: GetLocalCLASSNAME ( string InstanceName) Get functions in the form of GetLocalCLASSNAME work in the same way as regular Get functions, except clients may also instantiate missing instances and GetLocalFolder searches in different locations. Not meant to be used very much. Machine LOCALSTORAGE LOCALRESOURCES Server ServerStorage ServerStorage.Resources Client Players.LocalPlayer.PlayerScripts Players.LocalPlayer.PlayerScripts.Resources Step Object to search for Function call 1 BindableEvent Attacking inside GetLocalBindableEvent(\"Attacking\") 2 Folder BindableEvents in GetLocalFolder(\"BindableEvents\") 3 Folder LOCALSTORAGE.Resources LOCALRESOURCES Example local Attacking = Resources : GetLocalBindableEvent ( \"Attacking\" ) Here is what the above code would do if ran by the server versus what it would do if ran by a client: Server Client Warning In Play-Solo Mode, all local objects will go under ServerStorage , as there is no difference between the client and server. If you use identical Local-function calls on the client and server, this could cause conflicts in Play-Solo. The same problem applies to caches, which have \"Local\" appended to the front of the string to differentiate from regular caches. LOCALSTORAGE is typically just for GetLocalBindableEvent calls and having a place to store server-only Libraries, which are under GetLocalFolder(\"Resources\") .","title":"GetLocal functions"},{"location":"Resources/#getlocaltable","text":"table Resources: GetLocalTable ( string TableName) A function which caches a local table by string, and returns said table. Does not replicate. Useful for eliminating the need for _G or ModuleScripts which return an empty table. Note Because this is hard-coded and not procedurally generated, it doesn't obey the rules of other GetLocal functions. Example -- Can be used in any script on the same machine to get this table local MyItems = Resources : GetLocalTable ( \"MyItems\" ) -- {} Info Resources uses GetLocalTable internally, so you can access its internals using this function: -- Resources uses this table to cache LoadLibrary results local LoadedLibraries = Resources : GetLocalTable ( \"LoadedLibraries\" )","title":"GetLocalTable"},{"location":"Contributing/Image Standards/","text":"Image Standards \u00b6 If uploading icons, images must be 2x size so that high-density screens can still appreciate the beautiful icons. Icons should also be white (so that you can change ImageColor3 to whatever you want, including black). For example, for a 24x24 image (toggle_on) from material.io we would download the following. Go with the 48x48 image in the 2x folder. Pixels of 100% transparency (0% opacity/alpha) must have white color values. Bad Good To fix this in GIMP, do the following. First, create a new layer: Make sure it is filled with white pixels: Next, cut out all of the pixels, leaving only transparent white pixels. To do this, press R (open select tool), click on the image, hit Ctrl + A (select all), then hit Ctrl + X (cut). Click and drag on this transparent white layer and make sure it is on the bottom. Then Right Click + Merge Down Make sure to save color values from transparent pixels when you export the image.","title":"Image Standards"},{"location":"Contributing/Image Standards/#image-standards","text":"If uploading icons, images must be 2x size so that high-density screens can still appreciate the beautiful icons. Icons should also be white (so that you can change ImageColor3 to whatever you want, including black). For example, for a 24x24 image (toggle_on) from material.io we would download the following. Go with the 48x48 image in the 2x folder. Pixels of 100% transparency (0% opacity/alpha) must have white color values. Bad Good To fix this in GIMP, do the following. First, create a new layer: Make sure it is filled with white pixels: Next, cut out all of the pixels, leaving only transparent white pixels. To do this, press R (open select tool), click on the image, hit Ctrl + A (select all), then hit Ctrl + X (cut). Click and drag on this transparent white layer and make sure it is on the bottom. Then Right Click + Merge Down Make sure to save color values from transparent pixels when you export the image.","title":"Image Standards"},{"location":"Contributing/Website/","text":"Website \u00b6 The website is compiled from markdown ( .md ) files, so anyone can help write documentation for this website! Click here to visit the repository where the markdown files are kept. The documentation for the Signal library follows the format that will be standard.","title":"Website"},{"location":"Contributing/Website/#website","text":"The website is compiled from markdown ( .md ) files, so anyone can help write documentation for this website! Click here to visit the repository where the markdown files are kept. The documentation for the Signal library follows the format that will be standard.","title":"Website"},{"location":"Libraries/Sentry/","text":"Sentry \u00b6 Getting started \u00b6 Sign up for Sentry to get started. Navigate to the Projects tab on the left-hand side. In the top right, navigate to \"Add new...\" and select \"Project\" Don't select a project or framework, since this Library isn't officially supported by Sentry (but don't worry, it is still officially supported by RoStrap ). Give your project a name and create project! Now you need to find your DSN. You will hopefully be shown the following screen, but if not you can always find these in the \"Settings\" tab. You will need to locate a DSN that looks like this: Next, install this library using the RoStrap plugin , and navigate to the Server-side Sentry library. Under the configuration, modify the DSN variable to your DSN Now you have a working Sentry library! API \u00b6 The API is the same for both the client and the server. local Sentry = Resources : LoadLibrary ( \"Sentry\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) -- Optional Sentry : Post ( string Message [, string Traceback , < Enum , Enumeration > MessageType ]) -- Traceback defaults to debug.traceback() -- MessageType defaults to \"Error\" -- MessageType accepts any of the following Enumerations (or their corresponding numbers or strings) -- 0: Enumeration.IssueType.Debug -- 1: Enumeration.IssueType.Info -- 2: Enumeration.IssueType.Warning -- 3: Enumeration.IssueType.Error -- 4: Enumeration.IssueType.Fatal -- MessageType also accepts Roblox's MessageType Enums (but NOT their numbers or strings) -- Enum.MessageType.MessageError -- Enum.MessageType.MessageInfo -- Enum.MessageType.MessageOutput -- Enum.MessageType.MessageWarning It is intended to be easily compatible with the Try library local Try = Resources : LoadLibrary ( \"Try\" ) local Sentry = Resources : LoadLibrary ( \"Sentry\" ) Try ( function ( x ) error ( \"test client error \" .. x ) end , \"1\" ) : Catch ( Sentry . Post ) Here are your free Sentry rate limits: Enjoy!","title":"Sentry"},{"location":"Libraries/Sentry/#sentry","text":"","title":"Sentry"},{"location":"Libraries/Sentry/#getting-started","text":"Sign up for Sentry to get started. Navigate to the Projects tab on the left-hand side. In the top right, navigate to \"Add new...\" and select \"Project\" Don't select a project or framework, since this Library isn't officially supported by Sentry (but don't worry, it is still officially supported by RoStrap ). Give your project a name and create project! Now you need to find your DSN. You will hopefully be shown the following screen, but if not you can always find these in the \"Settings\" tab. You will need to locate a DSN that looks like this: Next, install this library using the RoStrap plugin , and navigate to the Server-side Sentry library. Under the configuration, modify the DSN variable to your DSN Now you have a working Sentry library!","title":"Getting started"},{"location":"Libraries/Sentry/#api","text":"The API is the same for both the client and the server. local Sentry = Resources : LoadLibrary ( \"Sentry\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) -- Optional Sentry : Post ( string Message [, string Traceback , < Enum , Enumeration > MessageType ]) -- Traceback defaults to debug.traceback() -- MessageType defaults to \"Error\" -- MessageType accepts any of the following Enumerations (or their corresponding numbers or strings) -- 0: Enumeration.IssueType.Debug -- 1: Enumeration.IssueType.Info -- 2: Enumeration.IssueType.Warning -- 3: Enumeration.IssueType.Error -- 4: Enumeration.IssueType.Fatal -- MessageType also accepts Roblox's MessageType Enums (but NOT their numbers or strings) -- Enum.MessageType.MessageError -- Enum.MessageType.MessageInfo -- Enum.MessageType.MessageOutput -- Enum.MessageType.MessageWarning It is intended to be easily compatible with the Try library local Try = Resources : LoadLibrary ( \"Try\" ) local Sentry = Resources : LoadLibrary ( \"Sentry\" ) Try ( function ( x ) error ( \"test client error \" .. x ) end , \"1\" ) : Catch ( Sentry . Post ) Here are your free Sentry rate limits: Enjoy!","title":"API"},{"location":"Libraries/Try/","text":"Try \u00b6 An asynchronous pcall-wrapper library for controlling the flow of error-prone, interdependent functions. How to use \u00b6 Upon requiring the Library, it returns a function called Try: -- Without RoStrap local Try = require ( TryLibrary ) -- With RoStrap local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Try = Resources : LoadLibrary ( \"Try\" ) API \u00b6 Attempt Try(Function, ...) Try calls pcall(Function, ...) on a separate thread , and returns a table Object called an Attempt . Attempt \u00b6 Attempt :Then(Callback) This method takes a callback of the form <function, callable table> Callback(...) , and pcalls it if the previous pcall didn't error , with ... being that which was returned by that pcall . This also returns the attempt, for further chaining. local HttpService = game : GetService ( 'HttpService' ) Try ( wait , 0.1 ) -- Try hashing the time : Then ( function ( Delta , ElapsedTime ) return HttpService : GetAsync ( 'http://md5.jsontest.com/?text=' .. Delta ) end ) -- Try decoding the response : Then ( function ( RawResponse ) return HttpService : JSONDecode ( RawResponse ) end ) -- Print the decoded response data : Then ( function ( Response ) print ( 'Input:' , Response . original , ' \\n MD5:' , Response . md5 ) end ) Attempt :Catch([string Patterns...], Callback) This method takes a callback of the form Variant Callback(string Error, string Stack, Attempt FailedAttempt) , and pcalls it if the previous pcall had an error . Errors can be optionally filtered by providing a list of patterns which the error should match , otherwise all errors are caught by the function. Once an attempt's error is caught, it will not be caught by the next chained :Catch method, unless Callback itself has an error. The attempt is then returned for chaining. If the first returned value from the attempt is an Attempt , it will be executed and the method will process its errors. local HttpService = game : GetService ( 'HttpService' ) Try ( HttpService . GetAsync , HttpService , 'http://httpstat.us/404' ) : Then ( function ( Data ) print ( 'Found' , Data ) end ) -- Catch when the URL doesn't exist : Catch ( 'HTTP 404' , function ( Error , Stack , Attempt ) warn ( 'Not found, error:' , Error ) end ) -- Catch any other error : Catch ( function ( Error , Stack , Attempt ) warn ( 'Unknown error:' , Error ) end ) httpstat.us is a good way to test Http request errors. Attempt :Retry() This method can only be called within a Catch callback. It retries the last function called in the chain before the error (with the same old arguments). Attempt.RetryCount is incremented each time the attempt is retried, and is reset after a Retry pcall doesn't error. You can use this method to retry a sequence of interdependent function calls that fail, and even limit the number of, or space out, retries. For example: local HttpService = game : GetService ( 'HttpService' ) Try ( HttpService . GetAsync , HttpService , 'http://httpstat.us/503' ) : Then ( function ( Data ) print ( 'Found' , Data ) end ) -- Catch when the server is having issues and retry : Catch ( 'HTTP 503' , 'Timeout was reached' , function ( Error , Stack , Attempt ) -- Limit the number of retries to 3 if Attempt . RetryCount < 3 then -- Space out each retry local BackoffTime = Attempt . RetryCount * 3 + 3 warn ( 'Retrying in' , BackoffTime , 'seconds...' ) wait ( BackoffTime ) -- Retry the attempt return Attempt : Retry () -- Give up if retry limit reached else warn ( 'Failed' ) end end ) -- Catch any other errors : Catch ( function ( Error , Stack , Attempt ) warn ( 'Unknown error:' , Error ) end ) Attempt :Wait() This method yields until all of the pcalls before it have finished running. Try ( wait , 0.5 ) : Then ( wait ) : Wait () print ( \"Hello!\" ) -- Runs after all of the threads finish A :Wait() can go anywhere in the Chain: local Attempt = Try ( wait , 2 ) print ( \"Hey!\" ) -- This runs immediately after Try is called on a separate thread Attempt : Wait () -- Wait until this Attempt's thread finishes yielding : Then ( function (...) -- This is still on a separate thread wait ( 1 ) print ( \"This was returned by wait(2)\" , ...) end ) print ( \"The Attempt has finished yielding!\" )","title":"Try"},{"location":"Libraries/Try/#try","text":"An asynchronous pcall-wrapper library for controlling the flow of error-prone, interdependent functions.","title":"Try"},{"location":"Libraries/Try/#how-to-use","text":"Upon requiring the Library, it returns a function called Try: -- Without RoStrap local Try = require ( TryLibrary ) -- With RoStrap local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Try = Resources : LoadLibrary ( \"Try\" )","title":"How to use"},{"location":"Libraries/Try/#api","text":"Attempt Try(Function, ...) Try calls pcall(Function, ...) on a separate thread , and returns a table Object called an Attempt .","title":"API"},{"location":"Libraries/Try/#attempt","text":"Attempt :Then(Callback) This method takes a callback of the form <function, callable table> Callback(...) , and pcalls it if the previous pcall didn't error , with ... being that which was returned by that pcall . This also returns the attempt, for further chaining. local HttpService = game : GetService ( 'HttpService' ) Try ( wait , 0.1 ) -- Try hashing the time : Then ( function ( Delta , ElapsedTime ) return HttpService : GetAsync ( 'http://md5.jsontest.com/?text=' .. Delta ) end ) -- Try decoding the response : Then ( function ( RawResponse ) return HttpService : JSONDecode ( RawResponse ) end ) -- Print the decoded response data : Then ( function ( Response ) print ( 'Input:' , Response . original , ' \\n MD5:' , Response . md5 ) end ) Attempt :Catch([string Patterns...], Callback) This method takes a callback of the form Variant Callback(string Error, string Stack, Attempt FailedAttempt) , and pcalls it if the previous pcall had an error . Errors can be optionally filtered by providing a list of patterns which the error should match , otherwise all errors are caught by the function. Once an attempt's error is caught, it will not be caught by the next chained :Catch method, unless Callback itself has an error. The attempt is then returned for chaining. If the first returned value from the attempt is an Attempt , it will be executed and the method will process its errors. local HttpService = game : GetService ( 'HttpService' ) Try ( HttpService . GetAsync , HttpService , 'http://httpstat.us/404' ) : Then ( function ( Data ) print ( 'Found' , Data ) end ) -- Catch when the URL doesn't exist : Catch ( 'HTTP 404' , function ( Error , Stack , Attempt ) warn ( 'Not found, error:' , Error ) end ) -- Catch any other error : Catch ( function ( Error , Stack , Attempt ) warn ( 'Unknown error:' , Error ) end ) httpstat.us is a good way to test Http request errors. Attempt :Retry() This method can only be called within a Catch callback. It retries the last function called in the chain before the error (with the same old arguments). Attempt.RetryCount is incremented each time the attempt is retried, and is reset after a Retry pcall doesn't error. You can use this method to retry a sequence of interdependent function calls that fail, and even limit the number of, or space out, retries. For example: local HttpService = game : GetService ( 'HttpService' ) Try ( HttpService . GetAsync , HttpService , 'http://httpstat.us/503' ) : Then ( function ( Data ) print ( 'Found' , Data ) end ) -- Catch when the server is having issues and retry : Catch ( 'HTTP 503' , 'Timeout was reached' , function ( Error , Stack , Attempt ) -- Limit the number of retries to 3 if Attempt . RetryCount < 3 then -- Space out each retry local BackoffTime = Attempt . RetryCount * 3 + 3 warn ( 'Retrying in' , BackoffTime , 'seconds...' ) wait ( BackoffTime ) -- Retry the attempt return Attempt : Retry () -- Give up if retry limit reached else warn ( 'Failed' ) end end ) -- Catch any other errors : Catch ( function ( Error , Stack , Attempt ) warn ( 'Unknown error:' , Error ) end ) Attempt :Wait() This method yields until all of the pcalls before it have finished running. Try ( wait , 0.5 ) : Then ( wait ) : Wait () print ( \"Hello!\" ) -- Runs after all of the threads finish A :Wait() can go anywhere in the Chain: local Attempt = Try ( wait , 2 ) print ( \"Hey!\" ) -- This runs immediately after Try is called on a separate thread Attempt : Wait () -- Wait until this Attempt's thread finishes yielding : Then ( function (...) -- This is still on a separate thread wait ( 1 ) print ( \"This was returned by wait(2)\" , ...) end ) print ( \"The Attempt has finished yielding!\" )","title":"Attempt"},{"location":"Libraries/Classes/Enumeration/","text":"Enumeration \u00b6 Pure-lua Enumeration implementation that function identically to Roblox Enums, except one may declare their own. Enumerations are a set of named reference constants for when a value must be a discrete value from a list. For example: local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) Enumeration . ButtonType = { \"Custom\" , \"Flat\" , \"Raised\" } Enumeration . SelectionControllerType = { \"Checkbox\" , \"Radio\" , \"Switch\" } local Radio = Enumeration . SelectionControllerType . Radio print ( Radio ) print ( Radio . EnumerationType ) print ( Radio . Name ) print ( Radio . Value ) > Enumeration.SelectionControllerType.Radio > SelectionControllerType > Radio > 1 Enumerations have a Value equal to their index in the declarative array minus one: Enumeration.ButtonType = { \"Custom\" \"Flat\" \"Raised\" } 0 1 2 In this implementation, we use Enumeration in the places where Roblox uses Enum : print ( \"All Roblox Enums:\" ) for i , EnumType in ipairs ( Enum : GetEnums ()) do print ( i , EnumType ) for j , EnumName in ipairs ( EnumType : GetEnumItems ()) do print ( \" \" , j , EnumName ) end end print ( \"All RoStrap Enumerations:\" ) for i , EnumerationType in ipairs ( Enumeration : GetEnumerations ()) do print ( i , EnumerationType ) for j , EnumName in ipairs ( EnumerationType : GetEnumerationItems ()) do print ( \" \" , j , EnumName ) end end","title":"Enumeration"},{"location":"Libraries/Classes/Enumeration/#enumeration","text":"Pure-lua Enumeration implementation that function identically to Roblox Enums, except one may declare their own. Enumerations are a set of named reference constants for when a value must be a discrete value from a list. For example: local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) Enumeration . ButtonType = { \"Custom\" , \"Flat\" , \"Raised\" } Enumeration . SelectionControllerType = { \"Checkbox\" , \"Radio\" , \"Switch\" } local Radio = Enumeration . SelectionControllerType . Radio print ( Radio ) print ( Radio . EnumerationType ) print ( Radio . Name ) print ( Radio . Value ) > Enumeration.SelectionControllerType.Radio > SelectionControllerType > Radio > 1 Enumerations have a Value equal to their index in the declarative array minus one: Enumeration.ButtonType = { \"Custom\" \"Flat\" \"Raised\" } 0 1 2 In this implementation, we use Enumeration in the places where Roblox uses Enum : print ( \"All Roblox Enums:\" ) for i , EnumType in ipairs ( Enum : GetEnums ()) do print ( i , EnumType ) for j , EnumName in ipairs ( EnumType : GetEnumItems ()) do print ( \" \" , j , EnumName ) end end print ( \"All RoStrap Enumerations:\" ) for i , EnumerationType in ipairs ( Enumeration : GetEnumerations ()) do print ( i , EnumerationType ) for j , EnumName in ipairs ( EnumerationType : GetEnumerationItems ()) do print ( \" \" , j , EnumName ) end end","title":"Enumeration"},{"location":"Libraries/Classes/PseudoInstance/","text":"PseudoInstance \u00b6 Summary Rigidly defined PseudoInstance class system based upon Roblox Instances. The goal is to create encapsulated instances whose state is simply a function of its externally accessible properties. In other words, a cloned instance should render exactly the same as the original instance. Library API \u00b6 PseudoInstance.new \u00b6 PseudoInstance PseudoInstance. new ( string ClassName, ...) Instantiates a new PseudoInstance of type ClassName . Arguments (...) are passed to the Init constructor. Example local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Shadow = PseudoInstance . new ( \"Shadow\" ) Shadow . Elevation = 8 -- this will cast to Enumeration.ShadowElevation.Elevation8 Shadow . Parent = Background -- Whatever Gui you wish Note Only classes which have been Registered may be instantiated. If you attempt to instantiate a class which has not been Registered , it will call Resources:LoadLibrary(ClassName) and try again. PseudoInstance.Make \u00b6 PseudoInstance PseudoInstance. Make ( string ClassName, dictionary Properties, ...) PseudoInstance.new wrapper which automatically assigns properties in dictionary Properties . Arguments passed to (...) must be dictionaries of Properties too. The only downside is you cannot pass any parameters to the Init constructor, but you probably don't need to. See the Make library's documentation for more information, as it works identically. Example local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Shadow = PseudoInstance . Make ( \"Shadow\" , { Elevation = 8 ; -- this will cast to Enumeration.ShadowElevation.Elevation8 Parent = Background ; -- Parent is set last }) PseudoInstance:Register \u00b6 PseudoTemplate PseudoInstance: Register ( string ClassName, table Template, table InheritsFrom = PseudoInstance) Registers a new class of PseudoInstances which can be instantiated via PseudoInstance.new(ClassName) . Please read all the documentation in the example below: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Typer = Resources : LoadLibrary ( \"Typer\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) Enumeration . PastaStyle = { \"Spaghetti\" , \"Fusilli\" , \"Penne\" , \"Rigatoni\" , \"Rotelle\" } local ClassNameTemplate = PseudoInstance : Register ( \"ClassName\" , { Events = { -- These are the events (see: Signal) of the PseudoInstance. These can be Connect()ed to, -- Fire()d, Wait()ed on, etc -- implicit numerical indeces define an Event member without Constuctors or Destructors \"OnPressed\" ; OnRightPressed = function ( self ) -- self is the PseudoInstance for which this Event is being constructed. -- Must return two functions, one constuctor and -- one destructor with which to call Signal.new (see docs) return function () end , function () end end ; }; Internals = { -- These values are internal-only and not externally accessible -- implicit numerical indeces are set by default to false, to be defined at run-time \"NumChildren\" ; Set = function ( self , Bool ) -- These can be set to anything return Bool == true and 1 or 0 end ; }; Methods = { Kill = function ( self ) -- Methods and the Init functions are sent an internal-access table version of self self . OnPressed : Fire () -- Internal Signal-access has full control return self : Set ( true ) end ; Destroy = function ( self , ...) print ( \"We are being destroyed!\" ) -- self:super() calls the superclass's method by the name of the first parameter -- In this case, this calls Superclass.Destroy(self, ...) self : super ( \"Destroy\" , ...) end ; -- When set to 0, it makes the class Abstract FunctionWhichMustBeImplementedByAClassThatInheritsFromThisOne = 0 ; }; Properties = { -- Can be set to a Typer value for typechecking Name = Typer . String ; -- This is equivalent to the previous declaration Name = Typer . AssignSignature ( 2 , Typer . String , function ( self , Value ) self : rawset ( \"Name\" , Value ) end ) -- Can also be constrained to a certain EnumerationType Style = Typer . EnumerationOfTypePastaStyle ; Parent = function ( self , Parent ) -- Always called with the Object and the Property value it is being set to -- Do stuff self : rawset ( \"Parent\" , Parent ) -- Make sure to rawset the Property to what it should be end ; }; Init = function ( self ) -- Called by PseudoInstance.new() -- Every PseudoInstance comes with a built-in Janitor which is called upon Destruction self . Janitor : Add ( workspace . ChildAdded : Connect ( function () end )) -- Sets externally-accessible Value of PseudoInstance directly -- without calling a Property setting function -- This can also be used for read-only values self : rawset ( \"IsPlayer\" , true ) -- Must be in your init function, to run the constructor in the superclass -- Will not exist after the Init function runs if the constructors resolved properly self : superinit () end ; }) -- Will Error, because `ClassName` is Abstract print ( pcall ( PseudoInstance . new , \"ClassName\" )) local MyClass = PseudoInstance : Register ( \"MyClass\" , { Methods = { FunctionWhichMustBeImplementedByAClassThatInheritsFromThisOne = function ( self ) end ; }; Init = function ( self ) self : superinit () end ; }, ClassNameTemplate ) local MyInstance = PseudoInstance . new ( \"MyClass\" ) MyInstance . Style = \"Rigatoni\" -- Gets cast to Enumeration MyInstance . Style = 3 -- Gets cast to Rigatoni MyInstance : Kill () -- Externally, one only may Connect() and Wait() on events MyInstance . OnPressed : Connect ( print ) -- Error: Cannot `Fire` externally. print ( pcall ( MyInstance . OnPressed . Fire , MyInstance . OnPressed )) print ( pcall ( function () MyInstance : Set ( true ) end )) -- Set does not exist externally","title":"PseudoInstance"},{"location":"Libraries/Classes/PseudoInstance/#pseudoinstance","text":"Summary Rigidly defined PseudoInstance class system based upon Roblox Instances. The goal is to create encapsulated instances whose state is simply a function of its externally accessible properties. In other words, a cloned instance should render exactly the same as the original instance.","title":"PseudoInstance"},{"location":"Libraries/Classes/PseudoInstance/#library-api","text":"","title":"Library API"},{"location":"Libraries/Classes/PseudoInstance/#pseudoinstancenew","text":"PseudoInstance PseudoInstance. new ( string ClassName, ...) Instantiates a new PseudoInstance of type ClassName . Arguments (...) are passed to the Init constructor. Example local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Shadow = PseudoInstance . new ( \"Shadow\" ) Shadow . Elevation = 8 -- this will cast to Enumeration.ShadowElevation.Elevation8 Shadow . Parent = Background -- Whatever Gui you wish Note Only classes which have been Registered may be instantiated. If you attempt to instantiate a class which has not been Registered , it will call Resources:LoadLibrary(ClassName) and try again.","title":"PseudoInstance.new"},{"location":"Libraries/Classes/PseudoInstance/#pseudoinstancemake","text":"PseudoInstance PseudoInstance. Make ( string ClassName, dictionary Properties, ...) PseudoInstance.new wrapper which automatically assigns properties in dictionary Properties . Arguments passed to (...) must be dictionaries of Properties too. The only downside is you cannot pass any parameters to the Init constructor, but you probably don't need to. See the Make library's documentation for more information, as it works identically. Example local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Shadow = PseudoInstance . Make ( \"Shadow\" , { Elevation = 8 ; -- this will cast to Enumeration.ShadowElevation.Elevation8 Parent = Background ; -- Parent is set last })","title":"PseudoInstance.Make"},{"location":"Libraries/Classes/PseudoInstance/#pseudoinstanceregister","text":"PseudoTemplate PseudoInstance: Register ( string ClassName, table Template, table InheritsFrom = PseudoInstance) Registers a new class of PseudoInstances which can be instantiated via PseudoInstance.new(ClassName) . Please read all the documentation in the example below: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Typer = Resources : LoadLibrary ( \"Typer\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) Enumeration . PastaStyle = { \"Spaghetti\" , \"Fusilli\" , \"Penne\" , \"Rigatoni\" , \"Rotelle\" } local ClassNameTemplate = PseudoInstance : Register ( \"ClassName\" , { Events = { -- These are the events (see: Signal) of the PseudoInstance. These can be Connect()ed to, -- Fire()d, Wait()ed on, etc -- implicit numerical indeces define an Event member without Constuctors or Destructors \"OnPressed\" ; OnRightPressed = function ( self ) -- self is the PseudoInstance for which this Event is being constructed. -- Must return two functions, one constuctor and -- one destructor with which to call Signal.new (see docs) return function () end , function () end end ; }; Internals = { -- These values are internal-only and not externally accessible -- implicit numerical indeces are set by default to false, to be defined at run-time \"NumChildren\" ; Set = function ( self , Bool ) -- These can be set to anything return Bool == true and 1 or 0 end ; }; Methods = { Kill = function ( self ) -- Methods and the Init functions are sent an internal-access table version of self self . OnPressed : Fire () -- Internal Signal-access has full control return self : Set ( true ) end ; Destroy = function ( self , ...) print ( \"We are being destroyed!\" ) -- self:super() calls the superclass's method by the name of the first parameter -- In this case, this calls Superclass.Destroy(self, ...) self : super ( \"Destroy\" , ...) end ; -- When set to 0, it makes the class Abstract FunctionWhichMustBeImplementedByAClassThatInheritsFromThisOne = 0 ; }; Properties = { -- Can be set to a Typer value for typechecking Name = Typer . String ; -- This is equivalent to the previous declaration Name = Typer . AssignSignature ( 2 , Typer . String , function ( self , Value ) self : rawset ( \"Name\" , Value ) end ) -- Can also be constrained to a certain EnumerationType Style = Typer . EnumerationOfTypePastaStyle ; Parent = function ( self , Parent ) -- Always called with the Object and the Property value it is being set to -- Do stuff self : rawset ( \"Parent\" , Parent ) -- Make sure to rawset the Property to what it should be end ; }; Init = function ( self ) -- Called by PseudoInstance.new() -- Every PseudoInstance comes with a built-in Janitor which is called upon Destruction self . Janitor : Add ( workspace . ChildAdded : Connect ( function () end )) -- Sets externally-accessible Value of PseudoInstance directly -- without calling a Property setting function -- This can also be used for read-only values self : rawset ( \"IsPlayer\" , true ) -- Must be in your init function, to run the constructor in the superclass -- Will not exist after the Init function runs if the constructors resolved properly self : superinit () end ; }) -- Will Error, because `ClassName` is Abstract print ( pcall ( PseudoInstance . new , \"ClassName\" )) local MyClass = PseudoInstance : Register ( \"MyClass\" , { Methods = { FunctionWhichMustBeImplementedByAClassThatInheritsFromThisOne = function ( self ) end ; }; Init = function ( self ) self : superinit () end ; }, ClassNameTemplate ) local MyInstance = PseudoInstance . new ( \"MyClass\" ) MyInstance . Style = \"Rigatoni\" -- Gets cast to Enumeration MyInstance . Style = 3 -- Gets cast to Rigatoni MyInstance : Kill () -- Externally, one only may Connect() and Wait() on events MyInstance . OnPressed : Connect ( print ) -- Error: Cannot `Fire` externally. print ( pcall ( MyInstance . OnPressed . Fire , MyInstance . OnPressed )) print ( pcall ( function () MyInstance : Set ( true ) end )) -- Set does not exist externally","title":"PseudoInstance:Register"},{"location":"Libraries/Classes/ReplicatedPseudoInstance/","text":"ReplicatedPseudoInstance \u00b6 Summary A ReplicatedPseudoInstance is an Instance which, when instantiated on the server, has built-in replication. While the parent is set to Workspace , ReplicatedStorage , or descendants of these, or set to Players , it will be Replicated to all players (including those who join the server later). If it is parented to an individual player or a descendant of an individual Player, it will replicate solely to that Player. If a property changes on the server, clients will be sent the new property's value and update their local version of the instance with the new property. Events which are fired on the client (by replicating instances originating from the server) are automatically fired on the server via a RemoteEvent. Currently, ReplicatedPseudoInstances which are Destroyed on the server do not have their destruction replicated. This behavior will be implemented in the future, however it is currently unnecessary as ChoiceDialog is the only RoStrap ReplicatedPseudoInstance. Feel free to submit a PR Warning In order for replication to work, the ReplicatedPseudoInstance library must be loaded on the client. Warning All events fired on a client must have LocalPlayer as the first parameter. On the server, it will use the automatically-passed PlayerFrom parameter (which is built-in to RemoteEvents) Example To make a library inherit from ReplicatedPseudoInstance, simply pass it in as the third parameter to PseudoInstance:Register . ChoiceDialog is a good example of a ReplicatedPseudoInstance, but here is a re-implementation of the ClickDetector object (but also passes along what face of an Object you clicked.) -- ClickDetector Class -- @author Validark local Players = game : GetService ( \"Players\" ) local Workspace = game : GetService ( \"Workspace\" ) local RunService = game : GetService ( \"RunService\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Debug = Resources : LoadLibrary ( \"Debug\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local ReplicatedPseudoInstance = Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local Parts = setmetatable ({}, { __mode = \"k\" }) local LocalPlayer if RunService : IsClient () then repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local Mouse = Players . LocalPlayer : GetMouse () local Targets = {} local MouseDowns = {} local CurrentMoval = 0 local MaximumInteger = 2 ^ 53 local function MouseMoved () local Target = Mouse . Target local ActiveIcon while Target do local Detectors = Parts [ Target ] if Detectors then for i = 1 , # Detectors do local Detector = Detectors [ i ] if Detector . MaxActivationDistance >= LocalPlayer : DistanceFromCharacter ( Target . Position ) then if not Targets [ Detector ] then Detector . MouseHoverEnter : Fire ( LocalPlayer ) end Targets [ Detector ] = CurrentMoval ActiveIcon = true Mouse . Icon = Detector . CursorIcon end end end Target = Target . Parent end for Detector , Moval in next , Targets do if Moval ~= CurrentMoval then Targets [ Detector ] = nil MouseDowns [ Detector ] = nil if not ActiveIcon then Mouse . Icon = \"\" end Detector . MouseHoverLeave : Fire ( LocalPlayer ) end end CurrentMoval = ( CurrentMoval + 1 ) % MaximumInteger end Mouse . Move : Connect ( MouseMoved ) local Connection = Workspace . CurrentCamera : GetPropertyChangedSignal ( \"CFrame\" ): Connect ( MouseMoved ) Workspace : GetPropertyChangedSignal ( \"CurrentCamera\" ): Connect ( function () Connection : Disconnect () Connection = Workspace . CurrentCamera : GetPropertyChangedSignal ( \"CFrame\" ): Connect ( MouseMoved ) end ) for i = 1 , 2 do local Event = i == 1 and \"MouseClick\" or \"RightMouseClick\" Mouse [ \"Button\" .. i .. \"Down\" ]: Connect ( function () local Target = Mouse . Target while Target do local Detectors = Parts [ Target ] if Detectors then for a = 1 , # Detectors do local Detector = Detectors [ a ] if Detector . MaxActivationDistance >= LocalPlayer : DistanceFromCharacter ( Target . Position ) then MouseDowns [ Detector ] = i end end end Target = Target . Parent end end ) Mouse [ \"Button\" .. i .. \"Up\" ]: Connect ( function () for Detector , Down in next , MouseDowns do if Down == i then Detector [ Event ]: Fire ( LocalPlayer , Mouse . TargetSurface ) end end end ) end end local function CompareClickDetectors ( a , b ) return a . __id < b . __id end return PseudoInstance : Register ( \"ClickDetector\" , { Internals = {}; Storage = {}; Properties = { MaxActivationDistance = Enumeration . ValueType . Number ; CursorIcon = Enumeration . ValueType . String ; Parent = function ( self , PVInstance ) if PVInstance == nil then return true elseif typeof ( PVInstance ) == \"Instance\" and PVInstance : IsA ( \"PVInstance\" ) then self . Janitor : LinkToInstance ( PVInstance ) if LocalPlayer then local OldParent = self . Parent if OldParent ~= PVInstance then if OldParent then local Data = Parts [ PVInstance ] if # Data == 1 and Data [ 1 ] == self then Parts [ PVInstance ] = nil else Data : RemoveElement ( self ) end end local Data = Parts [ PVInstance ] if Data then Data : Insert ( self ) else Parts [ PVInstance ] = SortedArray . new ({ self }, CompareClickDetectors ) end end end return true else Debug . Error ( \"The Parent of a \" .. self . ClassName .. \" must either be nil or a PVInstance\" ) end end ; }; Events = { \"MouseClick\" , \"MouseHoverEnter\" , \"MouseHoverLeave\" , \"RightMouseClick\" }; -- If these values are indexed from a ClickDetector, it will return a `Signal` Methods = {}; Init = function ( self , Id ) self . MaxActivationDistance = 32 self . CursorIcon = \"rbxassetid://1727841997\" -- 1727849582 self : superinit ( Id ) end ; }, ReplicatedPseudoInstance )","title":"ReplicatedPseudoInstance"},{"location":"Libraries/Classes/ReplicatedPseudoInstance/#replicatedpseudoinstance","text":"Summary A ReplicatedPseudoInstance is an Instance which, when instantiated on the server, has built-in replication. While the parent is set to Workspace , ReplicatedStorage , or descendants of these, or set to Players , it will be Replicated to all players (including those who join the server later). If it is parented to an individual player or a descendant of an individual Player, it will replicate solely to that Player. If a property changes on the server, clients will be sent the new property's value and update their local version of the instance with the new property. Events which are fired on the client (by replicating instances originating from the server) are automatically fired on the server via a RemoteEvent. Currently, ReplicatedPseudoInstances which are Destroyed on the server do not have their destruction replicated. This behavior will be implemented in the future, however it is currently unnecessary as ChoiceDialog is the only RoStrap ReplicatedPseudoInstance. Feel free to submit a PR Warning In order for replication to work, the ReplicatedPseudoInstance library must be loaded on the client. Warning All events fired on a client must have LocalPlayer as the first parameter. On the server, it will use the automatically-passed PlayerFrom parameter (which is built-in to RemoteEvents) Example To make a library inherit from ReplicatedPseudoInstance, simply pass it in as the third parameter to PseudoInstance:Register . ChoiceDialog is a good example of a ReplicatedPseudoInstance, but here is a re-implementation of the ClickDetector object (but also passes along what face of an Object you clicked.) -- ClickDetector Class -- @author Validark local Players = game : GetService ( \"Players\" ) local Workspace = game : GetService ( \"Workspace\" ) local RunService = game : GetService ( \"RunService\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Debug = Resources : LoadLibrary ( \"Debug\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local ReplicatedPseudoInstance = Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local Parts = setmetatable ({}, { __mode = \"k\" }) local LocalPlayer if RunService : IsClient () then repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local Mouse = Players . LocalPlayer : GetMouse () local Targets = {} local MouseDowns = {} local CurrentMoval = 0 local MaximumInteger = 2 ^ 53 local function MouseMoved () local Target = Mouse . Target local ActiveIcon while Target do local Detectors = Parts [ Target ] if Detectors then for i = 1 , # Detectors do local Detector = Detectors [ i ] if Detector . MaxActivationDistance >= LocalPlayer : DistanceFromCharacter ( Target . Position ) then if not Targets [ Detector ] then Detector . MouseHoverEnter : Fire ( LocalPlayer ) end Targets [ Detector ] = CurrentMoval ActiveIcon = true Mouse . Icon = Detector . CursorIcon end end end Target = Target . Parent end for Detector , Moval in next , Targets do if Moval ~= CurrentMoval then Targets [ Detector ] = nil MouseDowns [ Detector ] = nil if not ActiveIcon then Mouse . Icon = \"\" end Detector . MouseHoverLeave : Fire ( LocalPlayer ) end end CurrentMoval = ( CurrentMoval + 1 ) % MaximumInteger end Mouse . Move : Connect ( MouseMoved ) local Connection = Workspace . CurrentCamera : GetPropertyChangedSignal ( \"CFrame\" ): Connect ( MouseMoved ) Workspace : GetPropertyChangedSignal ( \"CurrentCamera\" ): Connect ( function () Connection : Disconnect () Connection = Workspace . CurrentCamera : GetPropertyChangedSignal ( \"CFrame\" ): Connect ( MouseMoved ) end ) for i = 1 , 2 do local Event = i == 1 and \"MouseClick\" or \"RightMouseClick\" Mouse [ \"Button\" .. i .. \"Down\" ]: Connect ( function () local Target = Mouse . Target while Target do local Detectors = Parts [ Target ] if Detectors then for a = 1 , # Detectors do local Detector = Detectors [ a ] if Detector . MaxActivationDistance >= LocalPlayer : DistanceFromCharacter ( Target . Position ) then MouseDowns [ Detector ] = i end end end Target = Target . Parent end end ) Mouse [ \"Button\" .. i .. \"Up\" ]: Connect ( function () for Detector , Down in next , MouseDowns do if Down == i then Detector [ Event ]: Fire ( LocalPlayer , Mouse . TargetSurface ) end end end ) end end local function CompareClickDetectors ( a , b ) return a . __id < b . __id end return PseudoInstance : Register ( \"ClickDetector\" , { Internals = {}; Storage = {}; Properties = { MaxActivationDistance = Enumeration . ValueType . Number ; CursorIcon = Enumeration . ValueType . String ; Parent = function ( self , PVInstance ) if PVInstance == nil then return true elseif typeof ( PVInstance ) == \"Instance\" and PVInstance : IsA ( \"PVInstance\" ) then self . Janitor : LinkToInstance ( PVInstance ) if LocalPlayer then local OldParent = self . Parent if OldParent ~= PVInstance then if OldParent then local Data = Parts [ PVInstance ] if # Data == 1 and Data [ 1 ] == self then Parts [ PVInstance ] = nil else Data : RemoveElement ( self ) end end local Data = Parts [ PVInstance ] if Data then Data : Insert ( self ) else Parts [ PVInstance ] = SortedArray . new ({ self }, CompareClickDetectors ) end end end return true else Debug . Error ( \"The Parent of a \" .. self . ClassName .. \" must either be nil or a PVInstance\" ) end end ; }; Events = { \"MouseClick\" , \"MouseHoverEnter\" , \"MouseHoverLeave\" , \"RightMouseClick\" }; -- If these values are indexed from a ClickDetector, it will return a `Signal` Methods = {}; Init = function ( self , Id ) self . MaxActivationDistance = 32 self . CursorIcon = \"rbxassetid://1727841997\" -- 1727849582 self : superinit ( Id ) end ; }, ReplicatedPseudoInstance )","title":"ReplicatedPseudoInstance"},{"location":"Libraries/DataTypes/Array/","text":"Array \u00b6 A few utility functions which can operate on Arrays. Purposefully light. Library API \u00b6 Array.Flatten \u00b6 a1 Array. Flatten ( array a1) Takes in an array, a1, which may have arrays inside of it. Unpacks all arrays in their proper place into a1. Returns a1. Example Array . Flatten {{ 1 , 2 }, 3 , 4 , { 5 , { 6 , {{ 7 , 8 }, 9 }, 10 }, 11 }, {}, 12 } --> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} Array.Contains \u00b6 number Array. Contains ( array a1, variant v) Returns the index at which v exists within array a1. Example print ( Array . Contains ({ 0 , 1 , 2 }, 2 )) --> 3 print ( Array . Contains ({ 0 , 1 , 2 }, 4 )) --> nil","title":"Array"},{"location":"Libraries/DataTypes/Array/#array","text":"A few utility functions which can operate on Arrays. Purposefully light.","title":"Array"},{"location":"Libraries/DataTypes/Array/#library-api","text":"","title":"Library API"},{"location":"Libraries/DataTypes/Array/#arrayflatten","text":"a1 Array. Flatten ( array a1) Takes in an array, a1, which may have arrays inside of it. Unpacks all arrays in their proper place into a1. Returns a1. Example Array . Flatten {{ 1 , 2 }, 3 , 4 , { 5 , { 6 , {{ 7 , 8 }, 9 }, 10 }, 11 }, {}, 12 } --> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}","title":"Array.Flatten"},{"location":"Libraries/DataTypes/Array/#arraycontains","text":"number Array. Contains ( array a1, variant v) Returns the index at which v exists within array a1. Example print ( Array . Contains ({ 0 , 1 , 2 }, 2 )) --> 3 print ( Array . Contains ({ 0 , 1 , 2 }, 4 )) --> nil","title":"Array.Contains"},{"location":"Libraries/DataTypes/HTMLParser/","text":"HTMLParser \u00b6 Demo: local HttpService = game : GetService ( \"HttpService\" ) local HTML = HTMLParser . new ( HttpService : GetAsync ( \"https://github.com/\" )) while HTML : Next (). Tag do print ( HTML . Tag , HTML . Data ) end -- Once an HTMLParser reaches its end, `Tag` and `Data` become nil -- The object can be used again for round 2! while HTML : Next (). Tag do print ( HTML . Tag , HTML . Data ) end API \u00b6 Instantiation: local HTML = HTMLParser . new ( HTML_DOCUMENT_STRING ) Advancement: HTML : Next () HTML : Next (): Next (): Next () Accessing data at the current state: print ( HTML . Tag ) -- /html (no <>) print ( HTML . Data ) -- This value is anything that occurs after HTML.Tag but before the next Tag","title":"HTMLParser"},{"location":"Libraries/DataTypes/HTMLParser/#htmlparser","text":"Demo: local HttpService = game : GetService ( \"HttpService\" ) local HTML = HTMLParser . new ( HttpService : GetAsync ( \"https://github.com/\" )) while HTML : Next (). Tag do print ( HTML . Tag , HTML . Data ) end -- Once an HTMLParser reaches its end, `Tag` and `Data` become nil -- The object can be used again for round 2! while HTML : Next (). Tag do print ( HTML . Tag , HTML . Data ) end","title":"HTMLParser"},{"location":"Libraries/DataTypes/HTMLParser/#api","text":"Instantiation: local HTML = HTMLParser . new ( HTML_DOCUMENT_STRING ) Advancement: HTML : Next () HTML : Next (): Next (): Next () Accessing data at the current state: print ( HTML . Tag ) -- /html (no <>) print ( HTML . Data ) -- This value is anything that occurs after HTML.Tag but before the next Tag","title":"API"},{"location":"Libraries/DataTypes/SortedArray/","text":"SortedArray \u00b6 A class to create sorted arrays. Must contain objects comparable to one another (that can use the < and == operators). Numbers and strings support these operators by default. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) local Array = SortedArray . new () -- Alternatively local Sorted = SortedArray . new { 2 , 1 , 5 , 3 } -- Will get `table.sort`ed Library API \u00b6 SortedArray.new \u00b6 table SortedArray. new ( array InitialSet [, function SortFunction]) Instantiates and returns a new SortedArray, with optional parameters. - InitialSet : Pass in an array of data which will be sorted upon instantiation. If this is omitted, an empty array is used. - SortFunction : An optional comparison function which is used to customize the element sorting, which will be given two elements a and b from the array as parameters. The function should return a boolean value specifying whether the first argument should be before the second argument in the sequence. If no comparison function is passed, the Lua-default a < b sorting is used. SortedArray API \u00b6 SortedArray:Concat() and SortedArray:Unpack() are equivalent to table.concat and unpack respectively. SortedArray:Insert \u00b6 number SortedArray: Insert ( Variant Element) Inserts an element in the proper place which would preserve the array's orderedness. Returns the index the element was inserted. local Sorted = SortedArray . new { 1 , 2 , 3 , 5 } print ( Sorted : Insert ( 4 )) -- 4 print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {1, 2, 3, 4, 5} SortedArray:Find \u00b6 number SortedArray: Find ( variant Signature [, function Eq, function Lt]) Finds an Element in a SortedArray and returns its position (or nil if non-existant). Signature is the element to find or something that will be matched by the Eq function. Eq is an optional function which checks for equality between the passed-in element and the other elements in the SortedArray. Lt is an optional less-than comparison function, which falls back on the comparison passed in from SortedArray.new Returns the numerical index of the element which was found, else nil. SortedArray:Copy \u00b6 table SortedArray: Copy () Returns a raw array with the same values. SortedArray:Clone \u00b6 table SortedArray: Clone () Returns a SortedArray clone. SortedArray:RemoveIndex \u00b6 variant SortedArray: RemoveIndex ( number Index) Removes an element from index, returning that element. The same as table.remove . SortedArray:RemoveElement \u00b6 variant SortedArray: RemoveElement ( variant Signature, function Eq, function Lt) Searches the array via SortedArray:Find(Signature, Eq, Lt) . If found, it removes the value and returns the value, otherwise returns nil. Only removes a single occurence. local Sorted = SortedArray . new { 1 , 2 , 3 , 3 , 3 , 3 , 5 } Sorted : RemoveElement ( 1 ) print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {2, 3, 3, 3, 3, 5} while Sorted : RemoveElement ( 3 ) do end print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {2, 5} SortedArray:SortIndex \u00b6 number SortedArray: SortIndex ( number Index) Removes the value at Index and re-inserts it. This is useful for when a value may have updated in a way that could change it's position in a SortedArray. Returns Index. SortedArray:SortElement \u00b6 number SortedArray: SortElement ( variant Signature [, function Eq, function Lt]) Calls RemoveElement(Signature, Eq, Lt) and re-inserts the value. This is useful for when a value may have updated in a way that could change it's position in a SortedArray. Returns Index. SortedArray:Sort \u00b6 void SortedArray: Sort () Does table.sort(self, Comparison_From_SortedArray_new)","title":"SortedArray"},{"location":"Libraries/DataTypes/SortedArray/#sortedarray","text":"A class to create sorted arrays. Must contain objects comparable to one another (that can use the < and == operators). Numbers and strings support these operators by default. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local SortedArray = Resources : LoadLibrary ( \"SortedArray\" ) local Array = SortedArray . new () -- Alternatively local Sorted = SortedArray . new { 2 , 1 , 5 , 3 } -- Will get `table.sort`ed","title":"SortedArray"},{"location":"Libraries/DataTypes/SortedArray/#library-api","text":"","title":"Library API"},{"location":"Libraries/DataTypes/SortedArray/#sortedarraynew","text":"table SortedArray. new ( array InitialSet [, function SortFunction]) Instantiates and returns a new SortedArray, with optional parameters. - InitialSet : Pass in an array of data which will be sorted upon instantiation. If this is omitted, an empty array is used. - SortFunction : An optional comparison function which is used to customize the element sorting, which will be given two elements a and b from the array as parameters. The function should return a boolean value specifying whether the first argument should be before the second argument in the sequence. If no comparison function is passed, the Lua-default a < b sorting is used.","title":"SortedArray.new"},{"location":"Libraries/DataTypes/SortedArray/#sortedarray-api","text":"SortedArray:Concat() and SortedArray:Unpack() are equivalent to table.concat and unpack respectively.","title":"SortedArray API"},{"location":"Libraries/DataTypes/SortedArray/#sortedarrayinsert","text":"number SortedArray: Insert ( Variant Element) Inserts an element in the proper place which would preserve the array's orderedness. Returns the index the element was inserted. local Sorted = SortedArray . new { 1 , 2 , 3 , 5 } print ( Sorted : Insert ( 4 )) -- 4 print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {1, 2, 3, 4, 5}","title":"SortedArray:Insert"},{"location":"Libraries/DataTypes/SortedArray/#sortedarrayfind","text":"number SortedArray: Find ( variant Signature [, function Eq, function Lt]) Finds an Element in a SortedArray and returns its position (or nil if non-existant). Signature is the element to find or something that will be matched by the Eq function. Eq is an optional function which checks for equality between the passed-in element and the other elements in the SortedArray. Lt is an optional less-than comparison function, which falls back on the comparison passed in from SortedArray.new Returns the numerical index of the element which was found, else nil.","title":"SortedArray:Find"},{"location":"Libraries/DataTypes/SortedArray/#sortedarraycopy","text":"table SortedArray: Copy () Returns a raw array with the same values.","title":"SortedArray:Copy"},{"location":"Libraries/DataTypes/SortedArray/#sortedarrayclone","text":"table SortedArray: Clone () Returns a SortedArray clone.","title":"SortedArray:Clone"},{"location":"Libraries/DataTypes/SortedArray/#sortedarrayremoveindex","text":"variant SortedArray: RemoveIndex ( number Index) Removes an element from index, returning that element. The same as table.remove .","title":"SortedArray:RemoveIndex"},{"location":"Libraries/DataTypes/SortedArray/#sortedarrayremoveelement","text":"variant SortedArray: RemoveElement ( variant Signature, function Eq, function Lt) Searches the array via SortedArray:Find(Signature, Eq, Lt) . If found, it removes the value and returns the value, otherwise returns nil. Only removes a single occurence. local Sorted = SortedArray . new { 1 , 2 , 3 , 3 , 3 , 3 , 5 } Sorted : RemoveElement ( 1 ) print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {2, 3, 3, 3, 3, 5} while Sorted : RemoveElement ( 3 ) do end print ( \"{\" .. Sorted : Concat ( \", \" ) .. \"}\" ) -- {2, 5}","title":"SortedArray:RemoveElement"},{"location":"Libraries/DataTypes/SortedArray/#sortedarraysortindex","text":"number SortedArray: SortIndex ( number Index) Removes the value at Index and re-inserts it. This is useful for when a value may have updated in a way that could change it's position in a SortedArray. Returns Index.","title":"SortedArray:SortIndex"},{"location":"Libraries/DataTypes/SortedArray/#sortedarraysortelement","text":"number SortedArray: SortElement ( variant Signature [, function Eq, function Lt]) Calls RemoveElement(Signature, Eq, Lt) and re-inserts the value. This is useful for when a value may have updated in a way that could change it's position in a SortedArray. Returns Index.","title":"SortedArray:SortElement"},{"location":"Libraries/DataTypes/SortedArray/#sortedarraysort","text":"void SortedArray: Sort () Does table.sort(self, Comparison_From_SortedArray_new)","title":"SortedArray:Sort"},{"location":"Libraries/DataTypes/Table/","text":"Table \u00b6 A few utility functions which operate on Tables. Purposefully light. Library API \u00b6 Table.Move \u00b6 a2 Table. Move ( array a1, number f, number e, number t, array a2) Moves elements [f, e] from array a1 into a2 starting at index t. Equivalent to Lua 5.3's table.move . -- @param table a1 from which to draw elements from range -- @param number f starting index for range -- @param number e ending index for range -- @param number t starting index to move elements from a1 within [f, e] -- @param table a2 the second table to move these elements to -- @default a2 = a1 -- @returns a2 Example local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Table = Resources : LoadLibrary ( \"Table\" ) local Debug = Resources : LoadLibrary ( \"Debug\" ) print ( Debug . TableToString ( Table . Move ({ 1 , 2 , 3 }, 1 , 3 , 2 ))) -- {1, 1, 2, 3} -- Explanation: -- Inserts {1, 2, 3} @ 2 Table.Lock \u00b6 userdata Table. Lock ( table Table [, function __ call ]) Returns a userdata with read-only access to a table. __call is the function which may be set as its metamethod of the same name. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Table = Resources : LoadLibrary ( \"Table\" ) local Debug = Resources : LoadLibrary ( \"Debug\" ) local t = Table . Lock { x = 5 } print ( t . x ) -- 5 print ( t . y ) -- error! t . x = 2 -- error! t . y = 3 -- error! local bar = Table . Lock ({ x = 2 ; y = 3 ; }, Debug . TableToString ) print ( bar ()) -- {x = 2, y = 3}","title":"Table"},{"location":"Libraries/DataTypes/Table/#table","text":"A few utility functions which operate on Tables. Purposefully light.","title":"Table"},{"location":"Libraries/DataTypes/Table/#library-api","text":"","title":"Library API"},{"location":"Libraries/DataTypes/Table/#tablemove","text":"a2 Table. Move ( array a1, number f, number e, number t, array a2) Moves elements [f, e] from array a1 into a2 starting at index t. Equivalent to Lua 5.3's table.move . -- @param table a1 from which to draw elements from range -- @param number f starting index for range -- @param number e ending index for range -- @param number t starting index to move elements from a1 within [f, e] -- @param table a2 the second table to move these elements to -- @default a2 = a1 -- @returns a2 Example local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Table = Resources : LoadLibrary ( \"Table\" ) local Debug = Resources : LoadLibrary ( \"Debug\" ) print ( Debug . TableToString ( Table . Move ({ 1 , 2 , 3 }, 1 , 3 , 2 ))) -- {1, 1, 2, 3} -- Explanation: -- Inserts {1, 2, 3} @ 2","title":"Table.Move"},{"location":"Libraries/DataTypes/Table/#tablelock","text":"userdata Table. Lock ( table Table [, function __ call ]) Returns a userdata with read-only access to a table. __call is the function which may be set as its metamethod of the same name. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Table = Resources : LoadLibrary ( \"Table\" ) local Debug = Resources : LoadLibrary ( \"Debug\" ) local t = Table . Lock { x = 5 } print ( t . x ) -- 5 print ( t . y ) -- error! t . x = 2 -- error! t . y = 3 -- error! local bar = Table . Lock ({ x = 2 ; y = 3 ; }, Debug . TableToString ) print ( bar ()) -- {x = 2, y = 3}","title":"Table.Lock"},{"location":"Libraries/Debugging/Debug/","text":"Debug \u00b6 Standard RoStrap debugging library local Debug = Resources : LoadLibrary ( \"Debug\" ) Library API \u00b6 Debug.TableToString \u00b6 string Debug. TableToString ( table Table [, bool Multiline = false , string TableName]) Pretty self-explanatory. Table is the table to convert into a string. String TableName puts local TableName = at the beginning. Multiline makes it multiline. Returns a string-readable version of Table. Debug.DirectoryToString \u00b6 string Debug. DirectoryToString ( RbxObject Object) A fixed version of GetFullName. Debug.Inspect \u00b6 string Debug. Inspect ( any Object) Returns a string representation of Object Debug.EscapeString \u00b6 string Debug. EscapeString ( string String) Turns strings into Lua-readable format. Returns Objects location in proper Lua format. Useful for when you are doing string-intensive coding. Those minus signs are so tricky! Debug.AlphabeticalOrder \u00b6 function Debug. AlphabeticalOrder ( table Dictionary) Iteration function that iterates over a dictionary in alphabetical order. Dictionary is that which will be iterated over in alphabetical order. Not case-sensitive. Example for Key , Value in next , Debug . AlphabeticalOrder { Apple = true , Noodles = 5 , Soup = false } do print ( Key , Value ) end Debug.Error \u00b6 void Debug. Error ( string ErrorMessage, ... strings argumentsToFormatIn ) Standard RoStrap Erroring system. Prefixing ErrorMessage with '!' makes it expect the [error origin script].Name as first parameter in {...} . Past the initial Error string, subsequent arguments get unpacked in a string.format of the error string. Assert falls back on Error. Error blames the latest item on the traceback as the cause of the error. Error makes it clear which Library and function are being misused. Debug.Assert \u00b6 Condition Debug. Assert (Variant Condition, ... strings TupleToSendToError) Returns Condition or Debug.Error(...) Debug.Warn \u00b6 void Debug. Warn ( string ErrorMessage, ... strings argumentsToFormatIn ) Functions the same as Debug.Error, but internally calls warn instead of error. Debug.UnionIteratorFunctions \u00b6 function Debug. UnionIteratorFunctions ( functions ...) Unions iterator functions in the order they are passed in, without duplicates from overlap. for i , v in Debug . UnionIteratorFunctions ( ipairs , pairs ){ 1 , 2 , 3 , 4 , a = 1 , b = 2 } do print ( i , v ) end","title":"Debug"},{"location":"Libraries/Debugging/Debug/#debug","text":"Standard RoStrap debugging library local Debug = Resources : LoadLibrary ( \"Debug\" )","title":"Debug"},{"location":"Libraries/Debugging/Debug/#library-api","text":"","title":"Library API"},{"location":"Libraries/Debugging/Debug/#debugtabletostring","text":"string Debug. TableToString ( table Table [, bool Multiline = false , string TableName]) Pretty self-explanatory. Table is the table to convert into a string. String TableName puts local TableName = at the beginning. Multiline makes it multiline. Returns a string-readable version of Table.","title":"Debug.TableToString"},{"location":"Libraries/Debugging/Debug/#debugdirectorytostring","text":"string Debug. DirectoryToString ( RbxObject Object) A fixed version of GetFullName.","title":"Debug.DirectoryToString"},{"location":"Libraries/Debugging/Debug/#debuginspect","text":"string Debug. Inspect ( any Object) Returns a string representation of Object","title":"Debug.Inspect"},{"location":"Libraries/Debugging/Debug/#debugescapestring","text":"string Debug. EscapeString ( string String) Turns strings into Lua-readable format. Returns Objects location in proper Lua format. Useful for when you are doing string-intensive coding. Those minus signs are so tricky!","title":"Debug.EscapeString"},{"location":"Libraries/Debugging/Debug/#debugalphabeticalorder","text":"function Debug. AlphabeticalOrder ( table Dictionary) Iteration function that iterates over a dictionary in alphabetical order. Dictionary is that which will be iterated over in alphabetical order. Not case-sensitive. Example for Key , Value in next , Debug . AlphabeticalOrder { Apple = true , Noodles = 5 , Soup = false } do print ( Key , Value ) end","title":"Debug.AlphabeticalOrder"},{"location":"Libraries/Debugging/Debug/#debugerror","text":"void Debug. Error ( string ErrorMessage, ... strings argumentsToFormatIn ) Standard RoStrap Erroring system. Prefixing ErrorMessage with '!' makes it expect the [error origin script].Name as first parameter in {...} . Past the initial Error string, subsequent arguments get unpacked in a string.format of the error string. Assert falls back on Error. Error blames the latest item on the traceback as the cause of the error. Error makes it clear which Library and function are being misused.","title":"Debug.Error"},{"location":"Libraries/Debugging/Debug/#debugassert","text":"Condition Debug. Assert (Variant Condition, ... strings TupleToSendToError) Returns Condition or Debug.Error(...)","title":"Debug.Assert"},{"location":"Libraries/Debugging/Debug/#debugwarn","text":"void Debug. Warn ( string ErrorMessage, ... strings argumentsToFormatIn ) Functions the same as Debug.Error, but internally calls warn instead of error.","title":"Debug.Warn"},{"location":"Libraries/Debugging/Debug/#debugunioniteratorfunctions","text":"function Debug. UnionIteratorFunctions ( functions ...) Unions iterator functions in the order they are passed in, without duplicates from overlap. for i , v in Debug . UnionIteratorFunctions ( ipairs , pairs ){ 1 , 2 , 3 , 4 , a = 1 , b = 2 } do print ( i , v ) end","title":"Debug.UnionIteratorFunctions"},{"location":"Libraries/Debugging/Typer/","text":"Typer \u00b6 Type Checker and Function Signature Assigner Library API \u00b6 Typer.AssignSignature \u00b6 function Typer. AssignSignature ([ number ParameterIndexToStartChecking = 1, ] types ... , function Callback) Returns a function which checks to make sure the arguments passed in exactly match the parameters specified. If they match, it will call Callback , otherwise it will error, stating which parameter caused the error and what was expected. Each parameter corresponds to the parameter with which the function is being called. Parameters should be arrays containing all valid strings which may be returned by typeof(parameter) . For example: {\"string\", \"number\", \"nil\"} would allow the corresponding parameter to be a string , number , or nil . Optionally, a table may have a [string TypeNameKey] = function Callback which may be called to determine whether a parameter is of the type TypeNameKey . The first parameter may optionally be a positive integer which is the first parameter AssignSignature should start checking. Example local Typer = Resources : LoadLibrary ( \"Typer\" ) local function IsButton ( Value , TypeOfString ) -- Value is the Parameter -- TypeOfString is the string returned by typeof(Value) return TypeOfString == \"Instance\" and ( Value : IsA ( \"TextButton\" ) or Value : IsA ( \"ImageButton\" )) end local foo = Typer . AssignSignature ({ \"string\" , \"number\" , \"nil\" , Button = IsButton }, function ( s ) -- s can be a string, number, nil, or Button (TextButton or ImageButton) -- Will error if `s` is none of the aforementioned -- Will error if 2 or more parameters are passed in return s end ) foo ( 2 ) -- 2 foo ( \"Hello\" ) -- Hello foo ({}) -- [Typer] {Foo} bad argument #1: expected Button or string or number or nil, got table {} local bar = Typer . AssignSignature ( 2 , { \"string\" }, { \"number\" }, function ( p1 , p2 , p3 ) -- The 2 signifies that the first checked parameter will be the second one -- Makes sure the 2nd parameter is a string, 3rd is a number -- The first parameter is not checked print ( p1 , p2 , p3 ) end ) bar ( false , \"\" , 1 ) Typer.Check \u00b6 boolean Typer. Check ( table PotentialType, any Parameter [, < string , number > ArgumentName]) Checks if an individual Parameter matches a PotentialType in the same way Typer.AssignSignature does. Returns Parameter if it's a truthy value. If it isn't a truthy value, return true. ArgumentName is just the name or number of the argument being Checked which can be used in the error message. Example local Debug = Resources : LoadLibrary ( \"Debug\" ) local Typer = Resources : LoadLibrary ( \"Typer\" ) local function foo ( a ) -- `assert` can be used instead of Debug.Assert return Debug . Assert ( Typer . Check ({ \"number\" }, a , 1 )) end foo ( 2 ) -- 2 foo ( \"Noodle\" ) -- [Script] {Foo} bad argument #1: expected number, got string Noodle Typer.MapDefinition \u00b6 function Typer. MapDefinition ( table Definition) Returns a function which returns the table if it matches the definition, or false, errorMessage if it doesn't. Example local PlayerDefinition = Typer . MapDefinition { Name = Typer . String ; UserId = Typer . PositiveInteger ; } local Player1 = { Name = \"Validark\" ; UserId = 2966752 ; } Player1 = assert ( PlayerDefinition ( Player1 )) -- Can also be used with AssignSignature Typer . AssignSignature ({ Player = PlayerDefinition }, function (...) print (...) end )( Player1 ) Typer.TYPE \u00b6 table Typer. TypeString Typer will procedurally generate tables which can be cast to valid types. These may be used with Typer.AssignSignature or Typer.Check to avoid duplicate table definitions. These tables may also be called directly, since their metatable __call is set to Typer.Check assert ( Typer . String ( \"Yup\" )) assert ( Typer . String ( 1 )) assert ( Typer . Number ( 1 )) assert ( Typer . Boolean ( true )) assert ( Typer . Function ( function () end ) assert ( Typer . Userdata ( newproxy ( false ))) local foo = Typer . AssignSignature ( Typer . String , function ( a ) print ( a ) end ) foo ( \"Hello, world!\" ) Built-in Types \u00b6 Key Matches Nil type(Object) = \"nil\" Boolean type(Object) = \"boolean\" Number type(Object) = \"number\" String type(Object) = \"string\" Userdata type(Object) = \"userdata\" Function type(Object) = \"function\" Thread type(Object) = \"thread\" Table type(Object) = \"table\" Typer accepts anything returned by typeof Custom Types \u00b6 Key Matches Any Anything Array A non-empty table with only numeric keys Dictionary A non-empty table with only non-numeric keys EmptyTable An empty table NonNil Any value which isn't nil Integer Any whole number PositiveInteger An integer higher than 0 NegativeInteger An integer lower than 0 NonPositiveInteger An integer lower than 0 or 0 NonNegativeInteger An integer higher than 0 or 0 PositiveNumber A number higher than 0 NegativeNumber A number lower than 0 NonPositiveNumber A number lower than 0 or 0 NonNegativeNumber A number higher than 0 or 0 Truthy Any value which isn't false or nil Falsy False or nil Enum An EnumType or EnumItem EnumType A roblox EnumType EnumItem An EnumItem True true False false Types from parsed strings \u00b6 Types separated by \"Or\" will function as expected. assert ( Typer . NumberOrString ( 2 )) assert ( Typer . OptionalBooleanOrNumberOrString ( 2 )) Prefixes \u00b6 Prefix Matches Optional Accepts nil as well InstanceOfClass Returns Object.ClassName == ClassName InstanceWhichIsA Returns Object:IsA(ClassName) EnumOfType Returns the (Roblox) Enum if it can be cast to it via its string, number, or reference EnumerationOfType Returns EnumerationType:Cast(Object) DictionaryOf Ensures it's a dictionary with values of a given type ArrayOf Ensures it's an array with values of a given type TableOf Ensures it's a table with values of a given type Warning You may not nest prefixes, but you may use multiple on the top level using \"Or\" Example assert ( Typer . ArrayOfStringsOrDictionaryOfNumbers { \"a\" , \"b\" , \"c\" }) assert ( Typer . ArrayOfStringsOrDictionaryOfNumbers { a = 1 ; b = 2 ; c = 3 ; })","title":"Typer"},{"location":"Libraries/Debugging/Typer/#typer","text":"Type Checker and Function Signature Assigner","title":"Typer"},{"location":"Libraries/Debugging/Typer/#library-api","text":"","title":"Library API"},{"location":"Libraries/Debugging/Typer/#typerassignsignature","text":"function Typer. AssignSignature ([ number ParameterIndexToStartChecking = 1, ] types ... , function Callback) Returns a function which checks to make sure the arguments passed in exactly match the parameters specified. If they match, it will call Callback , otherwise it will error, stating which parameter caused the error and what was expected. Each parameter corresponds to the parameter with which the function is being called. Parameters should be arrays containing all valid strings which may be returned by typeof(parameter) . For example: {\"string\", \"number\", \"nil\"} would allow the corresponding parameter to be a string , number , or nil . Optionally, a table may have a [string TypeNameKey] = function Callback which may be called to determine whether a parameter is of the type TypeNameKey . The first parameter may optionally be a positive integer which is the first parameter AssignSignature should start checking. Example local Typer = Resources : LoadLibrary ( \"Typer\" ) local function IsButton ( Value , TypeOfString ) -- Value is the Parameter -- TypeOfString is the string returned by typeof(Value) return TypeOfString == \"Instance\" and ( Value : IsA ( \"TextButton\" ) or Value : IsA ( \"ImageButton\" )) end local foo = Typer . AssignSignature ({ \"string\" , \"number\" , \"nil\" , Button = IsButton }, function ( s ) -- s can be a string, number, nil, or Button (TextButton or ImageButton) -- Will error if `s` is none of the aforementioned -- Will error if 2 or more parameters are passed in return s end ) foo ( 2 ) -- 2 foo ( \"Hello\" ) -- Hello foo ({}) -- [Typer] {Foo} bad argument #1: expected Button or string or number or nil, got table {} local bar = Typer . AssignSignature ( 2 , { \"string\" }, { \"number\" }, function ( p1 , p2 , p3 ) -- The 2 signifies that the first checked parameter will be the second one -- Makes sure the 2nd parameter is a string, 3rd is a number -- The first parameter is not checked print ( p1 , p2 , p3 ) end ) bar ( false , \"\" , 1 )","title":"Typer.AssignSignature"},{"location":"Libraries/Debugging/Typer/#typercheck","text":"boolean Typer. Check ( table PotentialType, any Parameter [, < string , number > ArgumentName]) Checks if an individual Parameter matches a PotentialType in the same way Typer.AssignSignature does. Returns Parameter if it's a truthy value. If it isn't a truthy value, return true. ArgumentName is just the name or number of the argument being Checked which can be used in the error message. Example local Debug = Resources : LoadLibrary ( \"Debug\" ) local Typer = Resources : LoadLibrary ( \"Typer\" ) local function foo ( a ) -- `assert` can be used instead of Debug.Assert return Debug . Assert ( Typer . Check ({ \"number\" }, a , 1 )) end foo ( 2 ) -- 2 foo ( \"Noodle\" ) -- [Script] {Foo} bad argument #1: expected number, got string Noodle","title":"Typer.Check"},{"location":"Libraries/Debugging/Typer/#typermapdefinition","text":"function Typer. MapDefinition ( table Definition) Returns a function which returns the table if it matches the definition, or false, errorMessage if it doesn't. Example local PlayerDefinition = Typer . MapDefinition { Name = Typer . String ; UserId = Typer . PositiveInteger ; } local Player1 = { Name = \"Validark\" ; UserId = 2966752 ; } Player1 = assert ( PlayerDefinition ( Player1 )) -- Can also be used with AssignSignature Typer . AssignSignature ({ Player = PlayerDefinition }, function (...) print (...) end )( Player1 )","title":"Typer.MapDefinition"},{"location":"Libraries/Debugging/Typer/#typertype","text":"table Typer. TypeString Typer will procedurally generate tables which can be cast to valid types. These may be used with Typer.AssignSignature or Typer.Check to avoid duplicate table definitions. These tables may also be called directly, since their metatable __call is set to Typer.Check assert ( Typer . String ( \"Yup\" )) assert ( Typer . String ( 1 )) assert ( Typer . Number ( 1 )) assert ( Typer . Boolean ( true )) assert ( Typer . Function ( function () end ) assert ( Typer . Userdata ( newproxy ( false ))) local foo = Typer . AssignSignature ( Typer . String , function ( a ) print ( a ) end ) foo ( \"Hello, world!\" )","title":"Typer.TYPE"},{"location":"Libraries/Debugging/Typer/#built-in-types","text":"Key Matches Nil type(Object) = \"nil\" Boolean type(Object) = \"boolean\" Number type(Object) = \"number\" String type(Object) = \"string\" Userdata type(Object) = \"userdata\" Function type(Object) = \"function\" Thread type(Object) = \"thread\" Table type(Object) = \"table\" Typer accepts anything returned by typeof","title":"Built-in Types"},{"location":"Libraries/Debugging/Typer/#custom-types","text":"Key Matches Any Anything Array A non-empty table with only numeric keys Dictionary A non-empty table with only non-numeric keys EmptyTable An empty table NonNil Any value which isn't nil Integer Any whole number PositiveInteger An integer higher than 0 NegativeInteger An integer lower than 0 NonPositiveInteger An integer lower than 0 or 0 NonNegativeInteger An integer higher than 0 or 0 PositiveNumber A number higher than 0 NegativeNumber A number lower than 0 NonPositiveNumber A number lower than 0 or 0 NonNegativeNumber A number higher than 0 or 0 Truthy Any value which isn't false or nil Falsy False or nil Enum An EnumType or EnumItem EnumType A roblox EnumType EnumItem An EnumItem True true False false","title":"Custom Types"},{"location":"Libraries/Debugging/Typer/#types-from-parsed-strings","text":"Types separated by \"Or\" will function as expected. assert ( Typer . NumberOrString ( 2 )) assert ( Typer . OptionalBooleanOrNumberOrString ( 2 ))","title":"Types from parsed strings"},{"location":"Libraries/Debugging/Typer/#prefixes","text":"Prefix Matches Optional Accepts nil as well InstanceOfClass Returns Object.ClassName == ClassName InstanceWhichIsA Returns Object:IsA(ClassName) EnumOfType Returns the (Roblox) Enum if it can be cast to it via its string, number, or reference EnumerationOfType Returns EnumerationType:Cast(Object) DictionaryOf Ensures it's a dictionary with values of a given type ArrayOf Ensures it's an array with values of a given type TableOf Ensures it's a table with values of a given type Warning You may not nest prefixes, but you may use multiple on the top level using \"Or\" Example assert ( Typer . ArrayOfStringsOrDictionaryOfNumbers { \"a\" , \"b\" , \"c\" }) assert ( Typer . ArrayOfStringsOrDictionaryOfNumbers { a = 1 ; b = 2 ; c = 3 ; })","title":"Prefixes"},{"location":"Libraries/Events/Janitor/","text":"Janitor \u00b6 Light-weight, flexible object for cleaning up connections, instances, or anything. This implementation covers all use cases, as it doesn't force you to rely on naive typechecking to guess how an instance should be cleaned up. Instead, the developer may specify any behavior for any object. local Janitor = Resources : LoadLibrary ( \"Janitor\" ) Library API \u00b6 Janitor.new \u00b6 Janitor Janitor. new () Instantiates a new Janitor object Janitor API \u00b6 Janitor:Add \u00b6 void Janitor: Add ( any Object, < string , true > MethodName = \"Destroy\" [, string Index]) Adds an Object to Janitor for later cleanup, where MethodName is the key of the method within Object which should be called at cleanup time. If the MethodName is true the Object itself will be called instead. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Example local Obliterator = Janitor . new () -- Queue the Part to be Destroyed at Cleanup time Obliterator : Add ( workspace . Part , \"Destroy\" ) -- Queue function to be called with `true` MethodName Obliterator : Add ( print , true ) -- This implementation allows you to specify behavior for any object Obliterator : Add ( Tween . new ( 0.5 , 0 , print ), \"Stop\" ) -- By passing an Index, the Object will occupy a namespace -- If \"CurrentTween\" already exists, it will call :Remove(\"CurrentTween\") before writing Obliterator : Add ( Tween . new ( 0.5 , 0 , print ), \"Stop\" , \"CurrentTween\" ) Note Objects not given an explicit MethodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to \"Disconnect\", functions will be assigned to true , and everything else will default to \"Destroy\". Not recommended, but hey, you do you. Janitor:Remove \u00b6 void Janitor: Remove ( string Index) Cleans up whatever Object was set to this namespace by the 3 rd parameter of :Add() Example Obliterator : Remove ( \"CurrentTween\" ) Janitor:Cleanup \u00b6 void Janitor: Cleanup () Calls each Object's MethodName (or calls the Object if MethodName == true ) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback). Example Obliterator : Cleanup () Obliterator () Janitor:LinkToInstance \u00b6 RbxScriptConnection Janitor: LinkToInstance ( RbxObject Instance [, boolean AllowMultiple]) \"Links\" this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroyed() and garbage collected. A Janitor may only be linked to one instance at a time, unless AllowMultiple is true. When called with a truthy AllowMultiple parameter, the Janitor will \"link\" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy AllowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy AllowMultiple parameter, if applicable. Example local Janitor = Janitor . new () Janitor : Add ( function () print ( \"Cleaning up!\" ) end ) do local Folder = Instance . new ( \"Folder\" ) Janitor : LinkToInstance ( Folder ) Folder : Destroy () end -- Cleaning up!","title":"Janitor"},{"location":"Libraries/Events/Janitor/#janitor","text":"Light-weight, flexible object for cleaning up connections, instances, or anything. This implementation covers all use cases, as it doesn't force you to rely on naive typechecking to guess how an instance should be cleaned up. Instead, the developer may specify any behavior for any object. local Janitor = Resources : LoadLibrary ( \"Janitor\" )","title":"Janitor"},{"location":"Libraries/Events/Janitor/#library-api","text":"","title":"Library API"},{"location":"Libraries/Events/Janitor/#janitornew","text":"Janitor Janitor. new () Instantiates a new Janitor object","title":"Janitor.new"},{"location":"Libraries/Events/Janitor/#janitor-api","text":"","title":"Janitor API"},{"location":"Libraries/Events/Janitor/#janitoradd","text":"void Janitor: Add ( any Object, < string , true > MethodName = \"Destroy\" [, string Index]) Adds an Object to Janitor for later cleanup, where MethodName is the key of the method within Object which should be called at cleanup time. If the MethodName is true the Object itself will be called instead. If passed an index it will occupy a namespace which can be Remove()d or overwritten. Example local Obliterator = Janitor . new () -- Queue the Part to be Destroyed at Cleanup time Obliterator : Add ( workspace . Part , \"Destroy\" ) -- Queue function to be called with `true` MethodName Obliterator : Add ( print , true ) -- This implementation allows you to specify behavior for any object Obliterator : Add ( Tween . new ( 0.5 , 0 , print ), \"Stop\" ) -- By passing an Index, the Object will occupy a namespace -- If \"CurrentTween\" already exists, it will call :Remove(\"CurrentTween\") before writing Obliterator : Add ( Tween . new ( 0.5 , 0 , print ), \"Stop\" , \"CurrentTween\" ) Note Objects not given an explicit MethodName will be passed into the typeof function for a very naive typecheck. RBXConnections will be assigned to \"Disconnect\", functions will be assigned to true , and everything else will default to \"Destroy\". Not recommended, but hey, you do you.","title":"Janitor:Add"},{"location":"Libraries/Events/Janitor/#janitorremove","text":"void Janitor: Remove ( string Index) Cleans up whatever Object was set to this namespace by the 3 rd parameter of :Add() Example Obliterator : Remove ( \"CurrentTween\" )","title":"Janitor:Remove"},{"location":"Libraries/Events/Janitor/#janitorcleanup","text":"void Janitor: Cleanup () Calls each Object's MethodName (or calls the Object if MethodName == true ) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback). Example Obliterator : Cleanup () Obliterator ()","title":"Janitor:Cleanup"},{"location":"Libraries/Events/Janitor/#janitorlinktoinstance","text":"RbxScriptConnection Janitor: LinkToInstance ( RbxObject Instance [, boolean AllowMultiple]) \"Links\" this Janitor to an Instance, such that the Janitor will Cleanup when the Instance is Destroyed() and garbage collected. A Janitor may only be linked to one instance at a time, unless AllowMultiple is true. When called with a truthy AllowMultiple parameter, the Janitor will \"link\" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy AllowMultiple parameter, the Janitor will overwrite the previous link which was also called with a falsy AllowMultiple parameter, if applicable. Example local Janitor = Janitor . new () Janitor : Add ( function () print ( \"Cleaning up!\" ) end ) do local Folder = Instance . new ( \"Folder\" ) Janitor : LinkToInstance ( Folder ) Folder : Destroy () end -- Cleaning up!","title":"Janitor:LinkToInstance"},{"location":"Libraries/Events/Signal/","text":"Signal \u00b6 Summary A class to create API-compatible Roblox Events This new version originally designed by Anaminus addresses two flaws in previous implementations: Previous versions held a reference to the last set of fired arguments. Arguments would be overridden if the signal was fired by a listener. Library API \u00b6 Signal.new \u00b6 Signal Signal. new ([ function Constructor, function Destructor]) Returns a new signal. Receives optional constructor and destructor functions. The constructor is called when the number of listeners/threads becomes greater than 0. The destructor is called when then number of threads/listeners becomes 0. The values returned by the constructor are passed into the destructor. Example local Signal = Resources : LoadLibrary ( \"Signal\" ) local Event = Signal . new () Signal API \u00b6 Signal:Fire \u00b6 void Signal: Fire (...) Fire the signal, passing the arguments to each listener and waiting threads. Arguments are always passed by reference. Signal:Wait \u00b6 (...) Signal: Wait () Block the current thread until the signal is fired. Returns the arguments passed to Fire. Signal:Connect \u00b6 PseudoScriptConnection Signal: Connect ( function Function [, any Argument]) Sets a function to be called when the signal is fired. The listener function receives the arguments passed to Fire. Returns a PseudoScriptConnection Signal:Destroy \u00b6 void Signal: Destroy () Disconnects all listeners and becomes unassociated with currently blocked threads. The signal becomes unusable and ready to be garbage collected. Fields \u00b6 Field Description Type Default value Event Interface which can only access Connect and Wait PseudoScriptSignal N / A Bindable Dispatches scheduler-compatible Threads BindableEvent Instance.new(\"BindableEvent\") Arguments Holds arguments for pending listener functions and Threads table { } Connections SignalConnections connected to the signal table { } Constructor Called when the number of listeners becomes greater than 0 function nil Destructor Called when then number of listeners becomes 0 function nil PseudoScriptConnection API \u00b6 void PseudoScriptConnection: Disconnect () Disconnects the listener, causing it to no longer be called when the signal is fired. Fields \u00b6 Field Description Type Default value Connected Whether the listener is connected bool true","title":"Signal"},{"location":"Libraries/Events/Signal/#signal","text":"Summary A class to create API-compatible Roblox Events This new version originally designed by Anaminus addresses two flaws in previous implementations: Previous versions held a reference to the last set of fired arguments. Arguments would be overridden if the signal was fired by a listener.","title":"Signal"},{"location":"Libraries/Events/Signal/#library-api","text":"","title":"Library API"},{"location":"Libraries/Events/Signal/#signalnew","text":"Signal Signal. new ([ function Constructor, function Destructor]) Returns a new signal. Receives optional constructor and destructor functions. The constructor is called when the number of listeners/threads becomes greater than 0. The destructor is called when then number of threads/listeners becomes 0. The values returned by the constructor are passed into the destructor. Example local Signal = Resources : LoadLibrary ( \"Signal\" ) local Event = Signal . new ()","title":"Signal.new"},{"location":"Libraries/Events/Signal/#signal-api","text":"","title":"Signal API"},{"location":"Libraries/Events/Signal/#signalfire","text":"void Signal: Fire (...) Fire the signal, passing the arguments to each listener and waiting threads. Arguments are always passed by reference.","title":"Signal:Fire"},{"location":"Libraries/Events/Signal/#signalwait","text":"(...) Signal: Wait () Block the current thread until the signal is fired. Returns the arguments passed to Fire.","title":"Signal:Wait"},{"location":"Libraries/Events/Signal/#signalconnect","text":"PseudoScriptConnection Signal: Connect ( function Function [, any Argument]) Sets a function to be called when the signal is fired. The listener function receives the arguments passed to Fire. Returns a PseudoScriptConnection","title":"Signal:Connect"},{"location":"Libraries/Events/Signal/#signaldestroy","text":"void Signal: Destroy () Disconnects all listeners and becomes unassociated with currently blocked threads. The signal becomes unusable and ready to be garbage collected.","title":"Signal:Destroy"},{"location":"Libraries/Events/Signal/#fields","text":"Field Description Type Default value Event Interface which can only access Connect and Wait PseudoScriptSignal N / A Bindable Dispatches scheduler-compatible Threads BindableEvent Instance.new(\"BindableEvent\") Arguments Holds arguments for pending listener functions and Threads table { } Connections SignalConnections connected to the signal table { } Constructor Called when the number of listeners becomes greater than 0 function nil Destructor Called when then number of listeners becomes 0 function nil","title":"Fields"},{"location":"Libraries/Events/Signal/#pseudoscriptconnection-api","text":"void PseudoScriptConnection: Disconnect () Disconnects the listener, causing it to no longer be called when the signal is fired.","title":"PseudoScriptConnection API"},{"location":"Libraries/Events/Signal/#fields_1","text":"Field Description Type Default value Connected Whether the listener is connected bool true","title":"Fields"},{"location":"Libraries/Helper/FastSpawn/","text":"FastSpawn \u00b6 Expensive method of running a function on a new thread without yielding a frame (like spawn ) and works within Roblox's thread scheduler. If passed arguments, they will be passed by reference. local t = {} print ( t ) FastSpawn ( function (...) wait ( 5 ) print (...) end , t )","title":"FastSpawn"},{"location":"Libraries/Helper/FastSpawn/#fastspawn","text":"Expensive method of running a function on a new thread without yielding a frame (like spawn ) and works within Roblox's thread scheduler. If passed arguments, they will be passed by reference. local t = {} print ( t ) FastSpawn ( function (...) wait ( 5 ) print (...) end , t )","title":"FastSpawn"},{"location":"Libraries/Helper/Make/","text":"Make \u00b6 A shortcut function for creating instances You probably shouldn't use this function, but if you really really like it, here it is. local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Make = Resources : LoadLibrary ( \"Make\" ) Make ( \"TextLabel\" ){ TextSize = 11 ; Font = \"Arial\" ; Name = \"Yup\" ; Parent = workspace ; } You can also create multiple instances at once. When you pass subsequent tables as parameters, the object created by the first table is Cloned and modified by the properties in its table. Each subsequent table generates a new instance. Make ( \"TextLabel\" )({ TextSize = 11 ; Font = \"Arial\" ; Name = \"Yup\" ; Parent = workspace ; }, { Name = \"So!\" ; Font = \"SourceSans\" ; }, { Name = \"Yellow!\" ; })","title":"Make"},{"location":"Libraries/Helper/Make/#make","text":"A shortcut function for creating instances You probably shouldn't use this function, but if you really really like it, here it is. local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Make = Resources : LoadLibrary ( \"Make\" ) Make ( \"TextLabel\" ){ TextSize = 11 ; Font = \"Arial\" ; Name = \"Yup\" ; Parent = workspace ; } You can also create multiple instances at once. When you pass subsequent tables as parameters, the object created by the first table is Cloned and modified by the properties in its table. Each subsequent table generates a new instance. Make ( \"TextLabel\" )({ TextSize = 11 ; Font = \"Arial\" ; Name = \"Yup\" ; Parent = workspace ; }, { Name = \"So!\" ; Font = \"SourceSans\" ; }, { Name = \"Yellow!\" ; })","title":"Make"},{"location":"Libraries/Input/Keys/","text":"Keys \u00b6 A light-weight library for simplifying Key input. API \u00b6 Keys \u00b6 The library returns a table Keys . Within this table, Keys from Enum.KeyCode can be indexed. local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local Keys = Resources : LoadLibrary ( \"Keys\" ) -- Each of these can be called with either a '.' or a ':', as it doesn't need 'self' Keys : Pause () -- Disconnects this module's InputEnded and InputBegan connections to UserInputService Keys : Resume () -- Reconnects what Pause disconnects local Q = Keys . Q -- returns a Key Object Key \u00b6 These table objects contain two custom Signals (technically, they are interfaces). KeyDown and KeyUp local Q = Keys . Q -- returns a Key Object Q . KeyDown : Connect ( function () print ( \"Q was pressed!\" ) end ) Q . KeyUp : Connect ( function () print ( \"Q was let go!\" ) end ) Signals \u00b6 In this module, KeyDown and KeyUp Signals have the following functions: local Shift = Keys . Shift . KeyDown local E = Keys . E . KeyDown E : Connect ( function () -- Connects a function print ( \"E!\" ) end ) E : Press () -- Fires open connections E : Fire () -- Same as Press() E : Wait () -- Yields until event fires ;( Shift + E ): Connect ( function () -- You can add 2 Keys together to get a combo event! print ( \"Shift + E!\" ) -- NOTE: Neither Shift nor E fire when (Shift + E) fires -- If you want to fire one or both of them, do Shift:Press() or E:Press() end ) Overhead \u00b6 This is an extremely light library. The tables within Keys are merely interface tables, and are not directly involved with calling connected Functions. The tables interface with a system that looks mostly like this: local KeyUps = { Q = function () print ( \"Q was let up\" ) end ; E = function () print ( \"E was let up\" ) end } UserInputService . InputEnded : Connect ( function ( Data , GuiInput ) if not GuiInput and Data . KeyCode ~= Enum . KeyCode . Unknown then local Function = KeyUps [ Data . KeyCode . Name ] if Function then Function () end end end )","title":"Keys"},{"location":"Libraries/Input/Keys/#keys","text":"A light-weight library for simplifying Key input.","title":"Keys"},{"location":"Libraries/Input/Keys/#api","text":"","title":"API"},{"location":"Libraries/Input/Keys/#keys_1","text":"The library returns a table Keys . Within this table, Keys from Enum.KeyCode can be indexed. local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local Keys = Resources : LoadLibrary ( \"Keys\" ) -- Each of these can be called with either a '.' or a ':', as it doesn't need 'self' Keys : Pause () -- Disconnects this module's InputEnded and InputBegan connections to UserInputService Keys : Resume () -- Reconnects what Pause disconnects local Q = Keys . Q -- returns a Key Object","title":"Keys"},{"location":"Libraries/Input/Keys/#key","text":"These table objects contain two custom Signals (technically, they are interfaces). KeyDown and KeyUp local Q = Keys . Q -- returns a Key Object Q . KeyDown : Connect ( function () print ( \"Q was pressed!\" ) end ) Q . KeyUp : Connect ( function () print ( \"Q was let go!\" ) end )","title":"Key"},{"location":"Libraries/Input/Keys/#signals","text":"In this module, KeyDown and KeyUp Signals have the following functions: local Shift = Keys . Shift . KeyDown local E = Keys . E . KeyDown E : Connect ( function () -- Connects a function print ( \"E!\" ) end ) E : Press () -- Fires open connections E : Fire () -- Same as Press() E : Wait () -- Yields until event fires ;( Shift + E ): Connect ( function () -- You can add 2 Keys together to get a combo event! print ( \"Shift + E!\" ) -- NOTE: Neither Shift nor E fire when (Shift + E) fires -- If you want to fire one or both of them, do Shift:Press() or E:Press() end )","title":"Signals"},{"location":"Libraries/Input/Keys/#overhead","text":"This is an extremely light library. The tables within Keys are merely interface tables, and are not directly involved with calling connected Functions. The tables interface with a system that looks mostly like this: local KeyUps = { Q = function () print ( \"Q was let up\" ) end ; E = function () print ( \"E was let up\" ) end } UserInputService . InputEnded : Connect ( function ( Data , GuiInput ) if not GuiInput and Data . KeyCode ~= Enum . KeyCode . Unknown then local Function = KeyUps [ Data . KeyCode . Name ] if Function then Function () end end end )","title":"Overhead"},{"location":"Libraries/Interpolation/Bezier/","text":"Bezier Module \u00b6 Used to create Bezier functions. API \u00b6 local EasingFunc = Bezier . new ( 0.17 , 0.67 , 0.83 , 0.67 ) Test and generate Bezier curves here at cubic-bezier.com or at greweb.me Credit: Math borrowed from here","title":"Bezier"},{"location":"Libraries/Interpolation/Bezier/#bezier-module","text":"Used to create Bezier functions.","title":"Bezier Module"},{"location":"Libraries/Interpolation/Bezier/#api","text":"local EasingFunc = Bezier . new ( 0.17 , 0.67 , 0.83 , 0.67 ) Test and generate Bezier curves here at cubic-bezier.com or at greweb.me Credit: Math borrowed from here","title":"API"},{"location":"Libraries/Interpolation/EasingFunctions/","text":"EasingFunctions \u00b6 These are the available EasingFunctions: Directionless In Out InOut OutIn Linear InQuad OutQuad InOutQuad OutInQuad Spring InCubic OutCubic InOutCubic OutInCubic SoftSpring InQuart OutQuart InOutQuart OutInQuart RevBack InQuint OutQuint InOutQuint OutInQuint RidiculousWiggle InSine OutSine InOutSine OutInSine Smooth InExpo OutExpo InOutExpo OutInExpo Smoother InCirc OutCirc InOutCirc OutInCirc Acceleration InElastic OutElastic InOutElastic OutInElastic Deceleration InBack OutBack InOutBack OutInBack Sharp InBounce OutBounce InOutBounce OutInBounce Standard This library returns an array of these functions, with values corresponding to their Enumerations' values. local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local EasingFunctions = Resources : LoadLibrary ( \"EasingFunctions\" ) local InSine = EasingFunctions [ Enumeration . EasingFunction . InSine . Value ] -- If you want an array of all EasingFunction Enumerations local EnumerationItems = Enumeration . EasingFunction : GetEnumerationItems () for i = 1 , # EnumerationItems do local EnumerationItem = EnumerationItems [ i ] print ( EnumerationItem , EasingFunctions [ EnumerationItem . Value ]) end","title":"EasingFunctions"},{"location":"Libraries/Interpolation/EasingFunctions/#easingfunctions","text":"These are the available EasingFunctions: Directionless In Out InOut OutIn Linear InQuad OutQuad InOutQuad OutInQuad Spring InCubic OutCubic InOutCubic OutInCubic SoftSpring InQuart OutQuart InOutQuart OutInQuart RevBack InQuint OutQuint InOutQuint OutInQuint RidiculousWiggle InSine OutSine InOutSine OutInSine Smooth InExpo OutExpo InOutExpo OutInExpo Smoother InCirc OutCirc InOutCirc OutInCirc Acceleration InElastic OutElastic InOutElastic OutInElastic Deceleration InBack OutBack InOutBack OutInBack Sharp InBounce OutBounce InOutBounce OutInBounce Standard This library returns an array of these functions, with values corresponding to their Enumerations' values. local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) local EasingFunctions = Resources : LoadLibrary ( \"EasingFunctions\" ) local InSine = EasingFunctions [ Enumeration . EasingFunction . InSine . Value ] -- If you want an array of all EasingFunction Enumerations local EnumerationItems = Enumeration . EasingFunction : GetEnumerationItems () for i = 1 , # EnumerationItems do local EnumerationItem = EnumerationItems [ i ] print ( EnumerationItem , EasingFunctions [ EnumerationItem . Value ]) end","title":"EasingFunctions"},{"location":"Libraries/Interpolation/Lerps/","text":"Lerps \u00b6 Contains functions which take arguments (variant beginning, variant last, number alpha [0, 1]) and returns a value in between beginning and last inclusive where 0 is beginning and 1 is last . Contains CIELUV color lerping written by Fractality:","title":"Lerps"},{"location":"Libraries/Interpolation/Lerps/#lerps","text":"Contains functions which take arguments (variant beginning, variant last, number alpha [0, 1]) and returns a value in between beginning and last inclusive where 0 is beginning and 1 is last . Contains CIELUV color lerping written by Fractality:","title":"Lerps"},{"location":"Libraries/Interpolation/Tween/","text":"Tween \u00b6 RoStrap's premier Tween Module built for Roblox. Allows you to write interpolation code faster with a clear and simple API. Declaration \u00b6 First let's load the module: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Tween = Resources : LoadLibrary ( \"Tween\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) Once you've loaded the Tween Module, there are two ways to create a Tween. You can either interpolate a property of an object, or create a custom Tween with a function you want called each Heartbeat frame. Library API \u00b6 Tween() \u00b6 TweenObject Tween (Object Object, string PropertyName, Variant EndValue, Enumeration.EasingFunction EasingFunction, number Time, bool Override = false , function (TweenStatus) Callback = nil , [ arg InitialParameter]) Tween function for tweening any property. Like GuiObject:TweenPosition() but the first two arguments are Object and Property. If InitialParameter isn't nil , it will be pushed to the first argument passed to the Callback. -- Localizing the `.Value` of an EasingFunction is fastest local OutQuad = Enumeration . EasingFunction . OutQuad . Value local Standard = Enumeration . EasingFunction . Standard . Value Tween ( workspace . Part , \"CFrame\" , CFrame . new ( 10 , 10 , 10 ), OutQuad , 2 , true ) Tween ( workspace . Part , \"Transparency\" , 1 , Standard , 2 , true ) Tween.new \u00b6 TweenObject Tween. new ( number Duration, string EasingFunctionName, function Callback, [ arg InitialParameter]) Tweens created with Tween.new will call Callback every tween Heartbeat frame, with EasingFunction interpolating from 0 to 1 over the allotted duration. If InitialParameter isn't nil , it will be pushed to the first argument passed to the Callback. Tween . new ( number Duration , string EasingFunctionName , function Callback ) local Deceleration = Enumeration . EasingFunction . Deceleration . Value local newTween = Tween . new ( 0.5 , Deceleration , function ( x ) print ( \"This will be called with each 'Frame' of this tween\" ) end ) TweenObject API \u00b6 Tween:Resume \u00b6 TweenObject Tween: Resume () Resumes a Tween that was Stop()ed Tween:Stop \u00b6 TweenObject Tween: Stop () Stops a Tween Tween:Wait \u00b6 TweenObject Tween: Wait () Yields until Tween finishes interpolating Tween:Restart \u00b6 TweenObject Tween: Restart () Makes the Tween go back to timeElapsed = 0 Fields \u00b6 Field Description Type Default value Running Whether the Tween is active bool true","title":"Tween"},{"location":"Libraries/Interpolation/Tween/#tween","text":"RoStrap's premier Tween Module built for Roblox. Allows you to write interpolation code faster with a clear and simple API.","title":"Tween"},{"location":"Libraries/Interpolation/Tween/#declaration","text":"First let's load the module: local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Tween = Resources : LoadLibrary ( \"Tween\" ) local Enumeration = Resources : LoadLibrary ( \"Enumeration\" ) Once you've loaded the Tween Module, there are two ways to create a Tween. You can either interpolate a property of an object, or create a custom Tween with a function you want called each Heartbeat frame.","title":"Declaration"},{"location":"Libraries/Interpolation/Tween/#library-api","text":"","title":"Library API"},{"location":"Libraries/Interpolation/Tween/#tween_1","text":"TweenObject Tween (Object Object, string PropertyName, Variant EndValue, Enumeration.EasingFunction EasingFunction, number Time, bool Override = false , function (TweenStatus) Callback = nil , [ arg InitialParameter]) Tween function for tweening any property. Like GuiObject:TweenPosition() but the first two arguments are Object and Property. If InitialParameter isn't nil , it will be pushed to the first argument passed to the Callback. -- Localizing the `.Value` of an EasingFunction is fastest local OutQuad = Enumeration . EasingFunction . OutQuad . Value local Standard = Enumeration . EasingFunction . Standard . Value Tween ( workspace . Part , \"CFrame\" , CFrame . new ( 10 , 10 , 10 ), OutQuad , 2 , true ) Tween ( workspace . Part , \"Transparency\" , 1 , Standard , 2 , true )","title":"Tween()"},{"location":"Libraries/Interpolation/Tween/#tweennew","text":"TweenObject Tween. new ( number Duration, string EasingFunctionName, function Callback, [ arg InitialParameter]) Tweens created with Tween.new will call Callback every tween Heartbeat frame, with EasingFunction interpolating from 0 to 1 over the allotted duration. If InitialParameter isn't nil , it will be pushed to the first argument passed to the Callback. Tween . new ( number Duration , string EasingFunctionName , function Callback ) local Deceleration = Enumeration . EasingFunction . Deceleration . Value local newTween = Tween . new ( 0.5 , Deceleration , function ( x ) print ( \"This will be called with each 'Frame' of this tween\" ) end )","title":"Tween.new"},{"location":"Libraries/Interpolation/Tween/#tweenobject-api","text":"","title":"TweenObject API"},{"location":"Libraries/Interpolation/Tween/#tweenresume","text":"TweenObject Tween: Resume () Resumes a Tween that was Stop()ed","title":"Tween:Resume"},{"location":"Libraries/Interpolation/Tween/#tweenstop","text":"TweenObject Tween: Stop () Stops a Tween","title":"Tween:Stop"},{"location":"Libraries/Interpolation/Tween/#tweenwait","text":"TweenObject Tween: Wait () Yields until Tween finishes interpolating","title":"Tween:Wait"},{"location":"Libraries/Interpolation/Tween/#tweenrestart","text":"TweenObject Tween: Restart () Makes the Tween go back to timeElapsed = 0","title":"Tween:Restart"},{"location":"Libraries/Interpolation/Tween/#fields","text":"Field Description Type Default value Running Whether the Tween is active bool true","title":"Fields"},{"location":"Libraries/Math/Leveler/","text":"Leveler \u00b6 Level and Experience class. WIP documentation: table Leveler.new(number PointsToStartWith or 0) Creates a Leveler object with the following API Leveler:Award(Points) The amount of points to add to Total Fields: Total : Total Exp Lvl : Current level Exp : Current Exp within level Next : Total Exp required to advance from this level to the next level Percent : decimal progress to next level Run this little demo and you will learn everything you need to know. local require = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )). LoadLibrary local Leveler = require ( \"Leveler\" ) local Kills = Leveler . new () table . foreach ( Kills , print ) print () Kills : Award () table . foreach ( Kills , print ) print () Kills : Award ( 6 ) table . foreach ( Kills , print )","title":"Leveler"},{"location":"Libraries/Math/Leveler/#leveler","text":"Level and Experience class. WIP documentation: table Leveler.new(number PointsToStartWith or 0) Creates a Leveler object with the following API Leveler:Award(Points) The amount of points to add to Total Fields: Total : Total Exp Lvl : Current level Exp : Current Exp within level Next : Total Exp required to advance from this level to the next level Percent : decimal progress to next level Run this little demo and you will learn everything you need to know. local require = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )). LoadLibrary local Leveler = require ( \"Leveler\" ) local Kills = Leveler . new () table . foreach ( Kills , print ) print () Kills : Award () table . foreach ( Kills , print ) print () Kills : Award ( 6 ) table . foreach ( Kills , print )","title":"Leveler"},{"location":"Libraries/Math/Normal/","text":"Normal \u00b6 Random numbers along a Normal curve number Normal(Average, StdDeviation) returns: Normal curve [-1, 1] * StdDeviation + Average","title":"Normal"},{"location":"Libraries/Math/Normal/#normal","text":"Random numbers along a Normal curve number Normal(Average, StdDeviation) returns: Normal curve [-1, 1] * StdDeviation + Average","title":"Normal"},{"location":"Libraries/Math/WeightedProbabilityFunction/","text":"WeightedProbabilityFunction \u00b6 Example: local require = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )). LoadLibrary local WeightedProbabilityFunction = require ( \"WeightedProbabilityFunction\" ) local CoinToss = WeightedProbabilityFunction . new { Heads = 0.5 ; Tails = 0.5 ; } local DiceRoll = WeightedProbabilityFunction . new { -- These weights are relative to one another, so if they are all 1, they will each have a 1/6 chance [ 1 ] = 1 ; [ 2 ] = 1 ; [ 3 ] = 1 ; [ 4 ] = 1 ; [ 5 ] = 1 ; [ 6 ] = 1 ; } local DiceRollOrCoinToss = WeightedProbabilityFunction . new { -- 9/10 of the time, toss a coin -- 1/10 of the time, roll a dice [ CoinToss ] = 9 ; [ DiceRoll ] = 1 ; } local t = {} for i = 1 , 10000 do local pick = DiceRollOrCoinToss () t [ pick ] = ( t [ pick ] or 0 ) + 1 end table . foreach ( t , print )","title":"WeightedProbabilityFunction"},{"location":"Libraries/Math/WeightedProbabilityFunction/#weightedprobabilityfunction","text":"Example: local require = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )). LoadLibrary local WeightedProbabilityFunction = require ( \"WeightedProbabilityFunction\" ) local CoinToss = WeightedProbabilityFunction . new { Heads = 0.5 ; Tails = 0.5 ; } local DiceRoll = WeightedProbabilityFunction . new { -- These weights are relative to one another, so if they are all 1, they will each have a 1/6 chance [ 1 ] = 1 ; [ 2 ] = 1 ; [ 3 ] = 1 ; [ 4 ] = 1 ; [ 5 ] = 1 ; [ 6 ] = 1 ; } local DiceRollOrCoinToss = WeightedProbabilityFunction . new { -- 9/10 of the time, toss a coin -- 1/10 of the time, roll a dice [ CoinToss ] = 9 ; [ DiceRoll ] = 1 ; } local t = {} for i = 1 , 10000 do local pick = DiceRollOrCoinToss () t [ pick ] = ( t [ pick ] or 0 ) + 1 end table . foreach ( t , print )","title":"WeightedProbabilityFunction"},{"location":"Libraries/RoStrapUI/AsymmetricTransformation/","text":"AsymmetricTransformation \u00b6 Transform function for Paper AsymmetricTransformation(GuiObject Button, UDim2 EndSize) Only supports Offsets, doesn't support Scaling","title":"AsymmetricTransformation"},{"location":"Libraries/RoStrapUI/AsymmetricTransformation/#asymmetrictransformation","text":"Transform function for Paper AsymmetricTransformation(GuiObject Button, UDim2 EndSize) Only supports Offsets, doesn't support Scaling","title":"AsymmetricTransformation"},{"location":"Libraries/RoStrapUI/Checkbox/","text":"Checkbox \u00b6 Registers a Material Design Checkbox PseudoInstance which can be instantiated via PseudoInstance.new(\"Checkbox\") local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PsuedoInstance\" ) local Checkbox = PseudoInstance . new ( \"Checkbox\" ) Checkbox API \u00b6 Checkbox inherits from PseudoInstance and SelectionController, so all properties, methods, and events of these can also be used on Checkboxes. Checkbox:SetChecked \u00b6 void Checkbox: SetChecked ( boolean Checked = not self .Checked) Sets the Checked property and animates to the new state. Fires OnChecked Fields \u00b6 Wrapped Properties \u00b6 Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Name string Parent Instance Position UDim2 LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance ZIndex int SelectionController Properties \u00b6 Property Type Description Indeterminate Boolean Whether the Checkbox is Indeterminate Checked Boolean Whether the Checkbox is Checked Disabled Boolean Whether the Checkbox is Disabled PrimaryColor3 Color3 The Color3 of the Checkbox when Checked Theme Enumeration.MaterialTheme \"Dark\" or \"Light\" colored frame when not Checked Events \u00b6 Event Description OnChecked Fires after the Checked property was changed Example \u00b6 local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color . Grey [ 200 ] Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local ReceiveUpdates = PseudoInstance . new ( \"Checkbox\" ) ReceiveUpdates . PrimaryColor3 = Color . Teal [ 500 ] ReceiveUpdates . Checked = true ReceiveUpdates . OnChecked : Connect ( function ( On ) print ( On ) -- On is the new value of `Checked` end ) ReceiveUpdates . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) ReceiveUpdates . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) ReceiveUpdates . Theme = \"Light\" -- \"Dark\" is also valid ReceiveUpdates . Parent = Frame","title":"Checkbox"},{"location":"Libraries/RoStrapUI/Checkbox/#checkbox","text":"Registers a Material Design Checkbox PseudoInstance which can be instantiated via PseudoInstance.new(\"Checkbox\") local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PsuedoInstance\" ) local Checkbox = PseudoInstance . new ( \"Checkbox\" )","title":"Checkbox"},{"location":"Libraries/RoStrapUI/Checkbox/#checkbox-api","text":"Checkbox inherits from PseudoInstance and SelectionController, so all properties, methods, and events of these can also be used on Checkboxes.","title":"Checkbox API"},{"location":"Libraries/RoStrapUI/Checkbox/#checkboxsetchecked","text":"void Checkbox: SetChecked ( boolean Checked = not self .Checked) Sets the Checked property and animates to the new state. Fires OnChecked","title":"Checkbox:SetChecked"},{"location":"Libraries/RoStrapUI/Checkbox/#fields","text":"","title":"Fields"},{"location":"Libraries/RoStrapUI/Checkbox/#wrapped-properties","text":"Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Name string Parent Instance Position UDim2 LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance ZIndex int","title":"Wrapped Properties"},{"location":"Libraries/RoStrapUI/Checkbox/#selectioncontroller-properties","text":"Property Type Description Indeterminate Boolean Whether the Checkbox is Indeterminate Checked Boolean Whether the Checkbox is Checked Disabled Boolean Whether the Checkbox is Disabled PrimaryColor3 Color3 The Color3 of the Checkbox when Checked Theme Enumeration.MaterialTheme \"Dark\" or \"Light\" colored frame when not Checked","title":"SelectionController Properties"},{"location":"Libraries/RoStrapUI/Checkbox/#events","text":"Event Description OnChecked Fires after the Checked property was changed","title":"Events"},{"location":"Libraries/RoStrapUI/Checkbox/#example","text":"local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color . Grey [ 200 ] Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local ReceiveUpdates = PseudoInstance . new ( \"Checkbox\" ) ReceiveUpdates . PrimaryColor3 = Color . Teal [ 500 ] ReceiveUpdates . Checked = true ReceiveUpdates . OnChecked : Connect ( function ( On ) print ( On ) -- On is the new value of `Checked` end ) ReceiveUpdates . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) ReceiveUpdates . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) ReceiveUpdates . Theme = \"Light\" -- \"Dark\" is also valid ReceiveUpdates . Parent = Frame","title":"Example"},{"location":"Libraries/RoStrapUI/ChoiceDialog/","text":"ChoiceDialog \u00b6 A two-step, single-choice Dialog with built-in Replication. This library registers a Material Design RadioGroup PseudoInstance which can be instantiated via PseudoInstance.new(\"ChoiceDialog\") . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local ChoiceDialog = PseudoInstance . new ( \"ChoiceDialog\" ) ChoiceDialog API \u00b6 ChoiceDialog inherits from ReplicatedPseudoInstance Demo \u00b6 -- If this is in a Script, it will Replicate this ChoiceDialog to every -- Player in the game and everyone who joins -- If this is in a LocalScript, it will generate it on the client only local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local PrimaryColor3 = Color . Teal [ 500 ] -- This is just a Color3 value local Dialog = PseudoInstance . new ( \"ChoiceDialog\" ) Dialog . HeaderText = \"Repository Location\" Dialog . Options = { \"ServerStorage\" , \"ServerScriptService\" } Dialog . DismissText = \"CANCEL\" Dialog . ConfirmText = \"INSTALL\" Dialog . PrimaryColor3 = PrimaryColor3 Dialog . OnConfirmed : Connect ( function ( Player , Choice ) print ( Player , Choice ) if Choice then -- Choice is a string of the option they chose else -- They chose Dismiss, so Choice is false end end ) Dialog . Parent = ReplicatedStorage","title":"ChoiceDialog"},{"location":"Libraries/RoStrapUI/ChoiceDialog/#choicedialog","text":"A two-step, single-choice Dialog with built-in Replication. This library registers a Material Design RadioGroup PseudoInstance which can be instantiated via PseudoInstance.new(\"ChoiceDialog\") . local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local ChoiceDialog = PseudoInstance . new ( \"ChoiceDialog\" )","title":"ChoiceDialog"},{"location":"Libraries/RoStrapUI/ChoiceDialog/#choicedialog-api","text":"ChoiceDialog inherits from ReplicatedPseudoInstance","title":"ChoiceDialog API"},{"location":"Libraries/RoStrapUI/ChoiceDialog/#demo","text":"-- If this is in a Script, it will Replicate this ChoiceDialog to every -- Player in the game and everyone who joins -- If this is in a LocalScript, it will generate it on the client only local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) Resources : LoadLibrary ( \"ReplicatedPseudoInstance\" ) local PrimaryColor3 = Color . Teal [ 500 ] -- This is just a Color3 value local Dialog = PseudoInstance . new ( \"ChoiceDialog\" ) Dialog . HeaderText = \"Repository Location\" Dialog . Options = { \"ServerStorage\" , \"ServerScriptService\" } Dialog . DismissText = \"CANCEL\" Dialog . ConfirmText = \"INSTALL\" Dialog . PrimaryColor3 = PrimaryColor3 Dialog . OnConfirmed : Connect ( function ( Player , Choice ) print ( Player , Choice ) if Choice then -- Choice is a string of the option they chose else -- They chose Dismiss, so Choice is false end end ) Dialog . Parent = ReplicatedStorage","title":"Demo"},{"location":"Libraries/RoStrapUI/Color/","text":"Color \u00b6 Color utilities with Material Design's 2014 Color Palette Library API \u00b6 Color.toRGBString \u00b6 string Color. toRGBString ( Color3 Color [, number Alpha]) Returns a string representation of the rgb or rgba value for a given Color. Color.toHexString \u00b6 string Color. toHexString ( Color3 Color [, number Alpha]) Returns a string representation of the hexidecimal Color code for a given Color. Color.fromHex \u00b6 Color3 Color. fromHex (< number , string > Hex) Converts a 3-digit or 6-digit hex color to a Color3. Takes in a string of the form: \"#FFFFFF\" or \"#FFF\" or a 6-digit hexadecimal number (e.g. 0xFFFFFF) Color.toHex \u00b6 number Color. toHex ( Color3 Color) Returns the Color in its hexidecimal-number form. Color.COLOR \u00b6 The Color table contains all the colors from the 2014 Material Design Color Pallete . These Colors are structured like so: Cyan = { [ 50 ] = rgb ( 224 , 247 , 250 ); [ 100 ] = rgb ( 178 , 235 , 242 ); [ 200 ] = rgb ( 128 , 222 , 234 ); [ 300 ] = rgb ( 77 , 208 , 225 ); [ 400 ] = rgb ( 38 , 198 , 218 ); [ 500 ] = rgb ( 0 , 188 , 212 ); [ 600 ] = rgb ( 0 , 172 , 193 ); [ 700 ] = rgb ( 0 , 151 , 167 ); [ 800 ] = rgb ( 0 , 131 , 143 ); [ 900 ] = rgb ( 0 , 96 , 100 ); Accent = { [ 100 ] = rgb ( 132 , 255 , 255 ); [ 200 ] = rgb ( 24 , 255 , 255 ); [ 400 ] = rgb ( 0 , 229 , 255 ); [ 700 ] = rgb ( 0 , 184 , 212 ); }; }; Example local Color = Resources : LoadLibrary ( \"Color\" ) local Cyan = Color . Cyan [ 500 ] local DarkCyan = Color . Cyan [ 900 ] local CyanAccent = Color . Cyan . Accent [ 700 ]","title":"Color"},{"location":"Libraries/RoStrapUI/Color/#color","text":"Color utilities with Material Design's 2014 Color Palette","title":"Color"},{"location":"Libraries/RoStrapUI/Color/#library-api","text":"","title":"Library API"},{"location":"Libraries/RoStrapUI/Color/#colortorgbstring","text":"string Color. toRGBString ( Color3 Color [, number Alpha]) Returns a string representation of the rgb or rgba value for a given Color.","title":"Color.toRGBString"},{"location":"Libraries/RoStrapUI/Color/#colortohexstring","text":"string Color. toHexString ( Color3 Color [, number Alpha]) Returns a string representation of the hexidecimal Color code for a given Color.","title":"Color.toHexString"},{"location":"Libraries/RoStrapUI/Color/#colorfromhex","text":"Color3 Color. fromHex (< number , string > Hex) Converts a 3-digit or 6-digit hex color to a Color3. Takes in a string of the form: \"#FFFFFF\" or \"#FFF\" or a 6-digit hexadecimal number (e.g. 0xFFFFFF)","title":"Color.fromHex"},{"location":"Libraries/RoStrapUI/Color/#colortohex","text":"number Color. toHex ( Color3 Color) Returns the Color in its hexidecimal-number form.","title":"Color.toHex"},{"location":"Libraries/RoStrapUI/Color/#colorcolor","text":"The Color table contains all the colors from the 2014 Material Design Color Pallete . These Colors are structured like so: Cyan = { [ 50 ] = rgb ( 224 , 247 , 250 ); [ 100 ] = rgb ( 178 , 235 , 242 ); [ 200 ] = rgb ( 128 , 222 , 234 ); [ 300 ] = rgb ( 77 , 208 , 225 ); [ 400 ] = rgb ( 38 , 198 , 218 ); [ 500 ] = rgb ( 0 , 188 , 212 ); [ 600 ] = rgb ( 0 , 172 , 193 ); [ 700 ] = rgb ( 0 , 151 , 167 ); [ 800 ] = rgb ( 0 , 131 , 143 ); [ 900 ] = rgb ( 0 , 96 , 100 ); Accent = { [ 100 ] = rgb ( 132 , 255 , 255 ); [ 200 ] = rgb ( 24 , 255 , 255 ); [ 400 ] = rgb ( 0 , 229 , 255 ); [ 700 ] = rgb ( 0 , 184 , 212 ); }; }; Example local Color = Resources : LoadLibrary ( \"Color\" ) local Cyan = Color . Cyan [ 500 ] local DarkCyan = Color . Cyan [ 900 ] local CyanAccent = Color . Cyan . Accent [ 700 ]","title":"Color.COLOR"},{"location":"Libraries/RoStrapUI/Radio/","text":"Radio \u00b6 Registers a Material Design Radio PseudoInstance which can be instantiated via PseudoInstance.new(\"Radio\") local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Radio = PseudoInstance . new ( \"Radio\" ) Radio API \u00b6 Radio inherits from PseudoInstance and SelectionController, so all properties, methods, and events of these can also be used on Checkboxes. Radio:SetChecked \u00b6 void Radio: SetChecked ( boolean Checked = not self .Checked) Sets the Checked property and animates to the new state. Fires OnChecked Fields \u00b6 Wrapped Properties \u00b6 Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Name string Parent Instance Position UDim2 LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance ZIndex int SelectionController Properties \u00b6 Property Type Description Checked Boolean Whether the Radio is Checked Disabled Boolean Whether the Radio is Disabled PrimaryColor3 Color3 The Color3 of the Radio when Checked Theme Enumeration.MaterialTheme \"Dark\" or \"Light\" colored frame when not Checked Events \u00b6 Event Description OnChecked Fires after the Checked property was changed Example \u00b6 local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color3 . fromRGB ( 50 , 50 , 50 ) Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Template = PseudoInstance . new ( \"Radio\" ) Template . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Template . Theme = \"Dark\" local RadioGroup = PseudoInstance . new ( \"RadioGroup\" ) local Choice1 = Template : Clone () Choice1 . PrimaryColor3 = Color . Red [ 500 ] Choice1 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 32 ) Choice1 . Parent = Frame local Choice2 = Template : Clone () Choice2 . PrimaryColor3 = Color . Yellow [ 500 ] Choice2 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Choice2 . Parent = Frame local Choice3 = Template : Clone () Choice3 . PrimaryColor3 = Color . Green [ 500 ] Choice3 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 32 ) Choice3 . Parent = Frame RadioGroup : Add ( Choice1 , \"Apples\" ) RadioGroup : Add ( Choice2 , \"Bananas\" ) RadioGroup : Add ( Choice3 , \"Carrots\" ) RadioGroup . SelectionChanged : Connect ( print )","title":"Radio"},{"location":"Libraries/RoStrapUI/Radio/#radio","text":"Registers a Material Design Radio PseudoInstance which can be instantiated via PseudoInstance.new(\"Radio\") local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local Radio = PseudoInstance . new ( \"Radio\" )","title":"Radio"},{"location":"Libraries/RoStrapUI/Radio/#radio-api","text":"Radio inherits from PseudoInstance and SelectionController, so all properties, methods, and events of these can also be used on Checkboxes.","title":"Radio API"},{"location":"Libraries/RoStrapUI/Radio/#radiosetchecked","text":"void Radio: SetChecked ( boolean Checked = not self .Checked) Sets the Checked property and animates to the new state. Fires OnChecked","title":"Radio:SetChecked"},{"location":"Libraries/RoStrapUI/Radio/#fields","text":"","title":"Fields"},{"location":"Libraries/RoStrapUI/Radio/#wrapped-properties","text":"Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Name string Parent Instance Position UDim2 LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance ZIndex int","title":"Wrapped Properties"},{"location":"Libraries/RoStrapUI/Radio/#selectioncontroller-properties","text":"Property Type Description Checked Boolean Whether the Radio is Checked Disabled Boolean Whether the Radio is Disabled PrimaryColor3 Color3 The Color3 of the Radio when Checked Theme Enumeration.MaterialTheme \"Dark\" or \"Light\" colored frame when not Checked","title":"SelectionController Properties"},{"location":"Libraries/RoStrapUI/Radio/#events","text":"Event Description OnChecked Fires after the Checked property was changed","title":"Events"},{"location":"Libraries/RoStrapUI/Radio/#example","text":"local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color3 . fromRGB ( 50 , 50 , 50 ) Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Template = PseudoInstance . new ( \"Radio\" ) Template . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Template . Theme = \"Dark\" local RadioGroup = PseudoInstance . new ( \"RadioGroup\" ) local Choice1 = Template : Clone () Choice1 . PrimaryColor3 = Color . Red [ 500 ] Choice1 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 32 ) Choice1 . Parent = Frame local Choice2 = Template : Clone () Choice2 . PrimaryColor3 = Color . Yellow [ 500 ] Choice2 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Choice2 . Parent = Frame local Choice3 = Template : Clone () Choice3 . PrimaryColor3 = Color . Green [ 500 ] Choice3 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 32 ) Choice3 . Parent = Frame RadioGroup : Add ( Choice1 , \"Apples\" ) RadioGroup : Add ( Choice2 , \"Bananas\" ) RadioGroup : Add ( Choice3 , \"Carrots\" ) RadioGroup . SelectionChanged : Connect ( print )","title":"Example"},{"location":"Libraries/RoStrapUI/RadioGroup/","text":"RadioGroup \u00b6 Registers a Material Design RadioGroup PseudoInstance which can be instantiated via PseudoInstance.new(\"RadioGroup\") . It acts as an interface for a set of Radio elements. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local RadioGroup = PseudoInstance . new ( \"RadioGroup\" ) RadioGroup API \u00b6 RadioGroup:Add \u00b6 void RadioGroup: Add ( RadioButton Item, variant Option) Adds an Item to the group. The Selection returned by GetSelection will become the Option when Item is selected. RadioGroup:GetSelection \u00b6 Option RadioGroup: GetSelection () Returns the current Selected Option . Events \u00b6 Event Description SelectionChanged Fires after Selection changes with the new selected Option Example \u00b6 local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color3 . fromRGB ( 50 , 50 , 50 ) Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Template = PseudoInstance . new ( \"Radio\" ) Template . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Template . Theme = \"Dark\" local RadioGroup = PseudoInstance . new ( \"RadioGroup\" ) local Choice1 = Template : Clone () Choice1 . PrimaryColor3 = Color . Red [ 500 ] Choice1 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 32 ) Choice1 . Parent = Frame local Choice2 = Template : Clone () Choice2 . PrimaryColor3 = Color . Yellow [ 500 ] Choice2 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Choice2 . Parent = Frame local Choice3 = Template : Clone () Choice3 . PrimaryColor3 = Color . Green [ 500 ] Choice3 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 32 ) Choice3 . Parent = Frame RadioGroup : Add ( Choice1 , \"Apples\" ) RadioGroup : Add ( Choice2 , \"Bananas\" ) RadioGroup : Add ( Choice3 , \"Carrots\" ) RadioGroup . SelectionChanged : Connect ( print )","title":"RadioGroup"},{"location":"Libraries/RoStrapUI/RadioGroup/#radiogroup","text":"Registers a Material Design RadioGroup PseudoInstance which can be instantiated via PseudoInstance.new(\"RadioGroup\") . It acts as an interface for a set of Radio elements. local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local PsuedoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local RadioGroup = PseudoInstance . new ( \"RadioGroup\" )","title":"RadioGroup"},{"location":"Libraries/RoStrapUI/RadioGroup/#radiogroup-api","text":"","title":"RadioGroup API"},{"location":"Libraries/RoStrapUI/RadioGroup/#radiogroupadd","text":"void RadioGroup: Add ( RadioButton Item, variant Option) Adds an Item to the group. The Selection returned by GetSelection will become the Option when Item is selected.","title":"RadioGroup:Add"},{"location":"Libraries/RoStrapUI/RadioGroup/#radiogroupgetselection","text":"Option RadioGroup: GetSelection () Returns the current Selected Option .","title":"RadioGroup:GetSelection"},{"location":"Libraries/RoStrapUI/RadioGroup/#events","text":"Event Description SelectionChanged Fires after Selection changes with the new selected Option","title":"Events"},{"location":"Libraries/RoStrapUI/RadioGroup/#example","text":"local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color3 . fromRGB ( 50 , 50 , 50 ) Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Template = PseudoInstance . new ( \"Radio\" ) Template . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Template . Theme = \"Dark\" local RadioGroup = PseudoInstance . new ( \"RadioGroup\" ) local Choice1 = Template : Clone () Choice1 . PrimaryColor3 = Color . Red [ 500 ] Choice1 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 32 ) Choice1 . Parent = Frame local Choice2 = Template : Clone () Choice2 . PrimaryColor3 = Color . Yellow [ 500 ] Choice2 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Choice2 . Parent = Frame local Choice3 = Template : Clone () Choice3 . PrimaryColor3 = Color . Green [ 500 ] Choice3 . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 32 ) Choice3 . Parent = Frame RadioGroup : Add ( Choice1 , \"Apples\" ) RadioGroup : Add ( Choice2 , \"Bananas\" ) RadioGroup : Add ( Choice3 , \"Carrots\" ) RadioGroup . SelectionChanged : Connect ( print )","title":"Example"},{"location":"Libraries/RoStrapUI/RippleButton/","text":"RippleButton \u00b6 Registers a Material Design RippleButton PseudoInstance which can be instantiated via PseudoInstance.new(\"RippleButton\") RippleButton API \u00b6 Fields \u00b6 Wrapped Properties \u00b6 Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Active boolean Name string Parent Instance Size UDim2 Position UDim2 TextTransparency string LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance Visible boolean ZIndex int Properties which access its TextLabel: Property Type Font Enum.Font Text string TextSize number TextXAlignment Enum.TextXAlignment TextYAlignment Enum.TextYAlignment Properties which access its Shadow: Property Type Elevation Enumeration.Elevation RippleButton Properties \u00b6 Property Type Description Disabled Boolean Whether the RippleButton is Disabled Tooltip string The tip to display upon hover, with \"\" being the disabled value BorderRadius Enumeration.BorderRadius How rounded the corners should be (0, 2, 4, or 8) Style Enumeration.ButtonStyle \"Flat\", \"Outlined\", or \"Contained\" style PrimaryColor3 Color3 The color of the text in Flat and Outlined styles or the color of the background in a Contained style when not Disabled Events \u00b6 Event Description OnPressed Fires after the Button was tapped or left-clicked OnRightPressed Fires after the Button was right-clicked OnMiddlePressed Fires after the Button was middle-clicked Example local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color . Grey [ 200 ] Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Flat = PseudoInstance . new ( \"RippleButton\" ) Flat . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Flat . Size = UDim2 . new ( 0 , 83 , 0 , 36 ) Flat . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 36 - 16 ) Flat . PrimaryColor3 = Color . Teal [ 500 ] Flat . BorderRadius = 4 Flat . Style = \"Flat\" Flat . Text = \"SUBMIT\" Flat . Parent = Frame local Outlined = Flat : Clone () Outlined . Style = \"Outlined\" Outlined . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Outlined . Parent = Frame local Contained = Flat : Clone () Contained . Style = \"Contained\" Contained . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 36 + 16 ) Contained . Parent = Frame Flat . OnPressed : Connect ( function () print ( \"Pressed Flat\" ) end ) Outlined . OnPressed : Connect ( function () print ( \"Pressed Outlined\" ) end ) Contained . OnPressed : Connect ( function () print ( \"Pressed Contained\" ) end )","title":"RippleButton"},{"location":"Libraries/RoStrapUI/RippleButton/#ripplebutton","text":"Registers a Material Design RippleButton PseudoInstance which can be instantiated via PseudoInstance.new(\"RippleButton\")","title":"RippleButton"},{"location":"Libraries/RoStrapUI/RippleButton/#ripplebutton-api","text":"","title":"RippleButton API"},{"location":"Libraries/RoStrapUI/RippleButton/#fields","text":"","title":"Fields"},{"location":"Libraries/RoStrapUI/RippleButton/#wrapped-properties","text":"Properties which access its top-level ImageButton: Property Type AnchorPoint Vector2 Active boolean Name string Parent Instance Size UDim2 Position UDim2 TextTransparency string LayoutOrder int NextSelectionDown Instance NextSelectionLeft Instance NextSelectionRight Instance NextSelectionUp Instance Visible boolean ZIndex int Properties which access its TextLabel: Property Type Font Enum.Font Text string TextSize number TextXAlignment Enum.TextXAlignment TextYAlignment Enum.TextYAlignment Properties which access its Shadow: Property Type Elevation Enumeration.Elevation","title":"Wrapped Properties"},{"location":"Libraries/RoStrapUI/RippleButton/#ripplebutton-properties","text":"Property Type Description Disabled Boolean Whether the RippleButton is Disabled Tooltip string The tip to display upon hover, with \"\" being the disabled value BorderRadius Enumeration.BorderRadius How rounded the corners should be (0, 2, 4, or 8) Style Enumeration.ButtonStyle \"Flat\", \"Outlined\", or \"Contained\" style PrimaryColor3 Color3 The color of the text in Flat and Outlined styles or the color of the background in a Contained style when not Disabled","title":"RippleButton Properties"},{"location":"Libraries/RoStrapUI/RippleButton/#events","text":"Event Description OnPressed Fires after the Button was tapped or left-clicked OnRightPressed Fires after the Button was right-clicked OnMiddlePressed Fires after the Button was middle-clicked Example local Players = game : GetService ( \"Players\" ) local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Resources = require ( ReplicatedStorage : WaitForChild ( \"Resources\" )) local Color = Resources : LoadLibrary ( \"Color\" ) local PseudoInstance = Resources : LoadLibrary ( \"PseudoInstance\" ) local LocalPlayer repeat LocalPlayer = Players . LocalPlayer until LocalPlayer or not wait () local PlayerGui repeat PlayerGui = LocalPlayer : FindFirstChildOfClass ( \"PlayerGui\" ) until PlayerGui or not wait () local Screen = Instance . new ( \"ScreenGui\" , PlayerGui ) local Frame = Instance . new ( \"Frame\" , Screen ) Frame . BackgroundColor3 = Color . Grey [ 200 ] Frame . BorderSizePixel = 0 Frame . Size = UDim2 . new ( 1 , 0 , 1 , 0 ) local Flat = PseudoInstance . new ( \"RippleButton\" ) Flat . AnchorPoint = Vector2 . new ( 0.5 , 0.5 ) Flat . Size = UDim2 . new ( 0 , 83 , 0 , 36 ) Flat . Position = UDim2 . new ( 0.5 , 0 , 0.5 , - 36 - 16 ) Flat . PrimaryColor3 = Color . Teal [ 500 ] Flat . BorderRadius = 4 Flat . Style = \"Flat\" Flat . Text = \"SUBMIT\" Flat . Parent = Frame local Outlined = Flat : Clone () Outlined . Style = \"Outlined\" Outlined . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 0 ) Outlined . Parent = Frame local Contained = Flat : Clone () Contained . Style = \"Contained\" Contained . Position = UDim2 . new ( 0.5 , 0 , 0.5 , 36 + 16 ) Contained . Parent = Frame Flat . OnPressed : Connect ( function () print ( \"Pressed Flat\" ) end ) Outlined . OnPressed : Connect ( function () print ( \"Pressed Outlined\" ) end ) Contained . OnPressed : Connect ( function () print ( \"Pressed Contained\" ) end )","title":"Events"},{"location":"Libraries/RoStrapUI/Rippler/","text":"Rippler \u00b6 Registers a Material Design Rippler PseudoInstance which can be instantiated via PseudoInstance.new(\"Rippler\") Rippler API \u00b6 Rippler:Down \u00b6 Tween Rippler: Down ([ number X, number Y]) Animates a Circular Ripple at position UDim2.new(0, X, 0, Y) within Container. Defaults to the center. Returns the Tween Object which is Tweening the Size of the Ripple. Rippler:Up \u00b6 void Rippler: Up () Fades the currently open Ripple out Rippler:Ripple \u00b6 void Rippler: Ripple ([ number X, number Y, number Duration = 0.15 ]) Calls Rippler:Down(X, Y) and calls Rippler:Up() after Duration Fields \u00b6 Property Type Description Style Enumeration.RipplerStyle Full, Icon, or Round BorderRadius Enumeration.BorderRadius How rounded the corners should be (0, 2, 4, or 8) RippleFadeDuration number How long it takes for a Ripple to Fade MaxRippleDiameter number A cap at how large the Ripples can get (defaults to math.huge) RippleExpandDuration number How long it takes a Ripple to expand to full size RippleColor3 Color3 The Color of the Ripples RippleTransparency number The Transparency of the Ripples Container GuiObject The parent to which Ripples are Parented When the Style is set to Enumeration.RipplerStyle.Icon , it will constrain the diameter of the Ripples to twice the height of the Container.","title":"Rippler"},{"location":"Libraries/RoStrapUI/Rippler/#rippler","text":"Registers a Material Design Rippler PseudoInstance which can be instantiated via PseudoInstance.new(\"Rippler\")","title":"Rippler"},{"location":"Libraries/RoStrapUI/Rippler/#rippler-api","text":"","title":"Rippler API"},{"location":"Libraries/RoStrapUI/Rippler/#ripplerdown","text":"Tween Rippler: Down ([ number X, number Y]) Animates a Circular Ripple at position UDim2.new(0, X, 0, Y) within Container. Defaults to the center. Returns the Tween Object which is Tweening the Size of the Ripple.","title":"Rippler:Down"},{"location":"Libraries/RoStrapUI/Rippler/#ripplerup","text":"void Rippler: Up () Fades the currently open Ripple out","title":"Rippler:Up"},{"location":"Libraries/RoStrapUI/Rippler/#ripplerripple","text":"void Rippler: Ripple ([ number X, number Y, number Duration = 0.15 ]) Calls Rippler:Down(X, Y) and calls Rippler:Up() after Duration","title":"Rippler:Ripple"},{"location":"Libraries/RoStrapUI/Rippler/#fields","text":"Property Type Description Style Enumeration.RipplerStyle Full, Icon, or Round BorderRadius Enumeration.BorderRadius How rounded the corners should be (0, 2, 4, or 8) RippleFadeDuration number How long it takes for a Ripple to Fade MaxRippleDiameter number A cap at how large the Ripples can get (defaults to math.huge) RippleExpandDuration number How long it takes a Ripple to expand to full size RippleColor3 Color3 The Color of the Ripples RippleTransparency number The Transparency of the Ripples Container GuiObject The parent to which Ripples are Parented When the Style is set to Enumeration.RipplerStyle.Icon , it will constrain the diameter of the Ripples to twice the height of the Container.","title":"Fields"},{"location":"Libraries/RoStrapUI/SelectionController/","text":"SelectionController \u00b6 The Class from which Checkbox and Radio inherit.","title":"SelectionController"},{"location":"Libraries/RoStrapUI/SelectionController/#selectioncontroller","text":"The Class from which Checkbox and Radio inherit.","title":"SelectionController"},{"location":"Libraries/RoStrapUI/Shadow/","text":"Shadow \u00b6 Registers a Material Design Shadow PseudoInstance which can be instantiated via PseudoInstance.new(\"Shadow\") ShadowElevation Enumeration \u00b6 ShadowElevation Castable number Elevation0 0 Elevation1 1 Elevation2 2 Elevation3 3 Elevation4 4 Elevation6 6 Elevation8 8 Elevation9 9 Elevation12 12 Elevation16 16 Shadow API \u00b6 Shadow:ChangeElevation \u00b6 void Shadow: ChangeElevation ( Enumeration . ShadowElevation Elevation [, number TweenTime = 0.175 ]) Animates a Shadow to a new Elevation over the course of TweenTime seconds. Fields \u00b6 Property Type Description Elevation Enumeration.ShadowElevation The Elevation of the Shadow Transparency number How transparent the Shadow is","title":"Shadow"},{"location":"Libraries/RoStrapUI/Shadow/#shadow","text":"Registers a Material Design Shadow PseudoInstance which can be instantiated via PseudoInstance.new(\"Shadow\")","title":"Shadow"},{"location":"Libraries/RoStrapUI/Shadow/#shadowelevation-enumeration","text":"ShadowElevation Castable number Elevation0 0 Elevation1 1 Elevation2 2 Elevation3 3 Elevation4 4 Elevation6 6 Elevation8 8 Elevation9 9 Elevation12 12 Elevation16 16","title":"ShadowElevation Enumeration"},{"location":"Libraries/RoStrapUI/Shadow/#shadow-api","text":"","title":"Shadow API"},{"location":"Libraries/RoStrapUI/Shadow/#shadowchangeelevation","text":"void Shadow: ChangeElevation ( Enumeration . ShadowElevation Elevation [, number TweenTime = 0.175 ]) Animates a Shadow to a new Elevation over the course of TweenTime seconds.","title":"Shadow:ChangeElevation"},{"location":"Libraries/RoStrapUI/Shadow/#fields","text":"Property Type Description Elevation Enumeration.ShadowElevation The Elevation of the Shadow Transparency number How transparent the Shadow is","title":"Fields"},{"location":"Libraries/RoStrapUI/Snackbar/","text":"WIP","title":"Snackbar"},{"location":"Libraries/Time/Date/","text":"Date \u00b6 Time and Date formatter mimicking the vanilla os.date function. local Date = Resources : LoadLibrary ( \"Date\" ) Demo: -- ISO 8601: print ( Date ( \"%FT%T\" )) -- 2020-01-01T01:03:05 print ( Date ( \"%Y-%m-%dT%H:%M:%S\" )) -- 2020-01-01T01:03:05 print ( Date ( \"%FT%T%#z\" )) -- 2020-01-01T01:03:05-05:00 -- Time: print ( Date ( \"%T\" )) -- 08:37:43 -- Date: print ( Date ( \"%D\" )) -- 01/12/20 Date functions just like the vanilla Lua os.date function, except padding can be toggled by inserting a '#' like so: print ( Date ( \"%#x\" , os.time ())) String reference: The following patterns will be replaced by their tags below: %c = \"%a %b %e %X %Y\" %D = \"%m/%d/%y\" %F = \"%Y-%m-%d\" %n = \"\\n\" %R = \"%H:%M\" %r = \"%I:%M:%S %p\" %T = \"%H:%M:%S\" %t = \"\\t\" %v = \"%e-%b-%Y\" %X = \"%T\" %x = \"%D\" %#c = \"%#x, %#X\" %#r = \"%#I:%M:%S %#p\" %#T = \"%#H:%M:%S\" %#X = \"%#T\" %#x = \"%A, %B %#d, %#Y\" The following tags will be replaced as follows: %% = the character `%\u00b4 %a = abbreviated weekday name (e.g., Wed) %A = full weekday name (e.g., Wednesday) %b = abbreviated month name (e.g., Sep) %B = full month name (e.g., September) %C = century: (year / 100) (padded) %d = day of the month (16) [01-31] %e = day of month as decimal number [ 1, 31] %g = Same year as in %G, but as a decimal number without century [00, 99] %G = a 4-digit year as a decimal number with century %H = hour, using a 24-hour clock (23) [00-23] %I = hour, using a 12-hour clock (11) [01-12] %j = day of year [001-366] (March 1st is treated as day 0 of year) %k = Hour in 24-hour format [ 0, 23] %l = Hour in 12-hour format [ 1, 12] %m = month (09) [01, 12] %M = minute (48) [00, 59] %p = either \"am\" or \"pm\" ('#' makes it uppercase) %s = Day of year suffix: e.g. 12th, 31st, 22nd %S = Second as decimal number [00, 59] %u = ISO 8601 weekday as number with Monday as 1 [1, 7] %U = Week of year, Sunday Based [00, 53] %V = week number of year (Monday as beginning of week) [01, 53] %w = weekday (3) [0-6 = Sunday-Saturday] %W = Week of year with Monday as first day of week [0, 53] %y = two-digit year (98) [00, 99] %Y = full year (1998) %z = Time zone offset from UTC in the form [+-]%02Hours%02Minutes, e.g. +0500 Example: print ( Date ( \"It is currently %#r\" )) --> It is currently 1:41:20 am","title":"Date"},{"location":"Libraries/Time/Date/#date","text":"Time and Date formatter mimicking the vanilla os.date function. local Date = Resources : LoadLibrary ( \"Date\" ) Demo: -- ISO 8601: print ( Date ( \"%FT%T\" )) -- 2020-01-01T01:03:05 print ( Date ( \"%Y-%m-%dT%H:%M:%S\" )) -- 2020-01-01T01:03:05 print ( Date ( \"%FT%T%#z\" )) -- 2020-01-01T01:03:05-05:00 -- Time: print ( Date ( \"%T\" )) -- 08:37:43 -- Date: print ( Date ( \"%D\" )) -- 01/12/20 Date functions just like the vanilla Lua os.date function, except padding can be toggled by inserting a '#' like so: print ( Date ( \"%#x\" , os.time ())) String reference: The following patterns will be replaced by their tags below: %c = \"%a %b %e %X %Y\" %D = \"%m/%d/%y\" %F = \"%Y-%m-%d\" %n = \"\\n\" %R = \"%H:%M\" %r = \"%I:%M:%S %p\" %T = \"%H:%M:%S\" %t = \"\\t\" %v = \"%e-%b-%Y\" %X = \"%T\" %x = \"%D\" %#c = \"%#x, %#X\" %#r = \"%#I:%M:%S %#p\" %#T = \"%#H:%M:%S\" %#X = \"%#T\" %#x = \"%A, %B %#d, %#Y\" The following tags will be replaced as follows: %% = the character `%\u00b4 %a = abbreviated weekday name (e.g., Wed) %A = full weekday name (e.g., Wednesday) %b = abbreviated month name (e.g., Sep) %B = full month name (e.g., September) %C = century: (year / 100) (padded) %d = day of the month (16) [01-31] %e = day of month as decimal number [ 1, 31] %g = Same year as in %G, but as a decimal number without century [00, 99] %G = a 4-digit year as a decimal number with century %H = hour, using a 24-hour clock (23) [00-23] %I = hour, using a 12-hour clock (11) [01-12] %j = day of year [001-366] (March 1st is treated as day 0 of year) %k = Hour in 24-hour format [ 0, 23] %l = Hour in 12-hour format [ 1, 12] %m = month (09) [01, 12] %M = minute (48) [00, 59] %p = either \"am\" or \"pm\" ('#' makes it uppercase) %s = Day of year suffix: e.g. 12th, 31st, 22nd %S = Second as decimal number [00, 59] %u = ISO 8601 weekday as number with Monday as 1 [1, 7] %U = Week of year, Sunday Based [00, 53] %V = week number of year (Monday as beginning of week) [01, 53] %w = weekday (3) [0-6 = Sunday-Saturday] %W = Week of year with Monday as first day of week [0, 53] %y = two-digit year (98) [00, 99] %Y = full year (1998) %z = Time zone offset from UTC in the form [+-]%02Hours%02Minutes, e.g. +0500 Example: print ( Date ( \"It is currently %#r\" )) --> It is currently 1:41:20 am","title":"Date"},{"location":"Libraries/Time/SyncedPoller/","text":"SyncedPoller \u00b6 Polling synced to os.time() local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local SyncedPoller = Resources : LoadLibrary ( \"SyncedPoller\" ) -- SyncedPoller.new(number Interval, function Func) SyncedPoller . new ( 10 , print ) Calls a function every Interval seconds, whenever (os.time() % Iterval == 0) . Functions are called with the current os.time() (with tick() precision).","title":"SyncedPoller"},{"location":"Libraries/Time/SyncedPoller/#syncedpoller","text":"Polling synced to os.time() local Resources = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"Resources\" )) local SyncedPoller = Resources : LoadLibrary ( \"SyncedPoller\" ) -- SyncedPoller.new(number Interval, function Func) SyncedPoller . new ( 10 , print ) Calls a function every Interval seconds, whenever (os.time() % Iterval == 0) . Functions are called with the current os.time() (with tick() precision).","title":"SyncedPoller"}]}